
=== FILE: .docs/BUGS_TRACKER.md ===
# AI Bug Tracker

| ID | Bug Description | Priority | Status | Date Found | Date Fixed | Session Notes |
|:---|:---|:---|:---|:---|:---|:---|
| 001 | **Race Condition in Booking Confirmation:** If two users try to book the same slot simultaneously, the first user succeeds, but the second user's session hangs or crashes because an unhandled `ValueError` is raised from the database layer. The user receives no feedback. | **Critical** | **Fixed** | 2024-05-21 | 2024-05-21 | The bug was fixed by implementing `try...except` error handling in `handlers/booking/confirmation.py` and adding a user-friendly error message. See Session 2024-05-21 in `CHANGELOG_AI.md`. |

=== FILE: .docs/CHANGELOG_AI.md ===
# AI Changelog

## Session 2024-05-21

### Task: Improve Bot Robustness and Fix Race Condition in Booking

#### Summary:
The user prioritized improving the existing functionality's stability over adding new features. A critical race condition vulnerability was identified and fixed in the booking confirmation process. This prevents double-booking the same time slot if two users attempt to book it simultaneously.

#### Initial Misstep and Correction:
*   **Initial Action (Rolled Back):** Initially, I proactively started implementing a new feature to make the "Masters" list interactive. This involved modifying `handlers/start.py`.
*   **User Feedback & Rollback:** The user correctly pointed out that this action was not confirmed. The changes were immediately reverted, and the focus was shifted to the user's priority: stability.

#### Investigation and Bug Discovery:
1.  **Hypothesis:** A potential race condition was hypothesized where two users could book the same slot.
2.  **Code Review (`utils/db/booking_queries.py`):** Analysis of the database layer showed that it correctly prevents double-booking by using a transaction and raising a `ValueError` if the slot is already taken. The initial assumption of a bug in the DB layer was incorrect.
3.  **Code Review (`handlers/booking/confirmation.py`):** Further analysis of the handler layer revealed the true issue: the `ValueError` raised by the database layer was **not handled**. This would cause the bot to hang or crash for the second user, providing no feedback.

#### Implementation of the Fix:
1.  **Modified `templates/beauty_salon.json`:**
    *   Updated the `slot_taken` message to be more user-friendly and provide clear instructions: *"–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤—ã–±—Ä–∞–Ω–Ω–æ–µ –≤–∞–º–∏ –≤—Ä–µ–º—è –±—ã–ª–æ —Ç–æ–ª—å–∫–æ —á—Ç–æ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–µ—Ä–Ω–∏—Ç–µ—Å—å –Ω–∞–∑–∞–¥ –∏ –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–π —Å–≤–æ–±–æ–¥–Ω—ã–π —Å–ª–æ—Ç."*

2.  **Modified `handlers/booking/confirmation.py`:**
    *   Wrapped the call to `db_manager.create_booking` in a `try...except ValueError` block to catch the specific error for a taken slot.
    *   Added logic to send the user the `slot_taken` message upon catching the error.
    *   Included an inline button "‚óÄÔ∏è –í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–µ –≤—Ä–µ–º—è" to allow the user to easily go back to the time selection step, improving UX.
    *   Added a general `except Exception` block to gracefully handle any other unexpected errors during booking.
    *   Refactored the admin notification logic into a separate `notify_admin_on_booking` function for better code readability and separation of concerns.

#### Files Modified:
*   `templates/beauty_salon.json`
*   `handlers/booking/confirmation.py`

#### Files Verified (No Changes Needed):
*   `utils/db/booking_queries.py`

=== FILE: .docs/CONTEXT_FOR_AI.md ===
# –ö–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–æ–µ–∫—Ç–∞ –¥–ª—è AI

## 1. –û–±—â–µ–µ –æ–ø–∏—Å–∞–Ω–∏–µ

**–ù–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–∞:** Telegram-–±–æ—Ç –¥–ª—è –æ–Ω–ª–∞–π–Ω-–∑–∞–ø–∏—Å–∏ (Booking Bot).

**–¶–µ–ª—å:** –ü—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å –±–∏–∑–Ω–µ—Å–∞–º (—Å–∞–ª–æ–Ω—ã –∫—Ä–∞—Å–æ—Ç—ã, –∞–≤—Ç–æ—Å–µ—Ä–≤–∏—Å—ã, –∫–ª–∏–Ω–∏–∫–∏ –∏ —Ç.–¥.) –≥–æ—Ç–æ–≤–æ–≥–æ Telegram-–±–æ—Ç–∞ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞ –∑–∞–ø–∏—Å–∏ –∫–ª–∏–µ–Ω—Ç–æ–≤ –Ω–∞ —É—Å–ª—É–≥–∏.

**–ö–æ–Ω–µ—á–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:** –ö–ª–∏–µ–Ω—Ç—ã –±–∏–∑–Ω–µ—Å–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —Ö–æ—Ç—è—Ç –∑–∞–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ —É—Å–ª—É–≥—É.

**–í–ª–∞–¥–µ–ª–µ—Ü –ø—Ä–æ–µ–∫—Ç–∞:** –í—ã—Å—Ç—É–ø–∞–µ—Ç –≤ —Ä–æ–ª–∏ –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –ø—Ä–æ–¥—É–∫—Ç–∞, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–æ–º.

## 2. –ö–ª—é—á–µ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å

- **–í—ã–±–æ—Ä —É—Å–ª—É–≥:** –ö–ª–∏–µ–Ω—Ç –º–æ–∂–µ—Ç –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å —É—Å–ª—É–≥–∏, —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º.
- **–í—ã–±–æ—Ä –º–∞—Å—Ç–µ—Ä–∞:** –ö–ª–∏–µ–Ω—Ç –º–æ–∂–µ—Ç –≤—ã–±—Ä–∞—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –º–∞—Å—Ç–µ—Ä–∞ –∏–ª–∏ –æ–ø—Ü–∏—é "–õ—é–±–æ–π —Å–≤–æ–±–æ–¥–Ω—ã–π".
- **–í—ã–±–æ—Ä –¥–∞—Ç—ã –∏ –≤—Ä–µ–º–µ–Ω–∏:** –ö–ª–∏–µ–Ω—Ç –≤–∏–¥–∏—Ç –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Å–ª–æ—Ç—ã –≤ –∫–∞–ª–µ–Ω–¥–∞—Ä–µ –∏ –≤—ã–±–∏—Ä–∞–µ—Ç —É–¥–æ–±–Ω–æ–µ –≤—Ä–µ–º—è.
- **–°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–∞:** –ë–æ—Ç –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç –∏–º—è, —Ç–µ–ª–µ—Ñ–æ–Ω –∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π.
- **–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏:** –ö–ª–∏–µ–Ω—Ç –≤–∏–¥–∏—Ç —Å–≤–æ–¥–∫—É –ø–æ —Å–≤–æ–µ–π –∑–∞–ø–∏—Å–∏ –∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç –µ—ë.
- **–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:**
  - –ö–ª–∏–µ–Ω—Ç –ø–æ–ª—É—á–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—à–Ω–æ–π –∑–∞–ø–∏—Å–∏.
  - –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –±–∏–∑–Ω–µ—Å–∞ –ø–æ–ª—É—á–∞–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –Ω–æ–≤–æ–π –∑–∞–ø–∏—Å–∏.
- **–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å—è–º–∏:** –ö–ª–∏–µ–Ω—Ç –º–æ–∂–µ—Ç –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å —Å–≤–æ–∏ –ø—Ä–µ–¥—Å—Ç–æ—è—â–∏–µ –∑–∞–ø–∏—Å–∏ –∏ –æ—Ç–º–µ–Ω–∏—Ç—å –∏—Ö.

## 3. –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π —Å—Ç–µ–∫

- **–Ø–∑—ã–∫:** Python
- **–û—Å–Ω–æ–≤–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ (Telegram Bot):** `aiogram 3.x`
- **–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö:** `SQLite` (–ª–æ–∫–∞–ª—å–Ω—ã–π —Ñ–∞–π–ª `database.db`)
- **–ü—Ä–∏–Ω—Ü–∏–ø—ã:** –ö–æ–Ω–µ—á–Ω—ã–µ –∞–≤—Ç–æ–º–∞—Ç—ã (FSM) –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º –¥–∏–∞–ª–æ–≥–∞.

## 4. –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞

- **`/` (–∫–æ—Ä–µ–Ω—å):** –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ–∞–π–ª—ã, –≤–∫–ª—é—á–∞—è `main.py` (—Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞).
- **`.docs/`:** –í—Å—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –¥–ª—è AI-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–æ–≤.
- **`handlers/`:** –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π –∏ –∫–æ–ª–±—ç–∫–æ–≤ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.
  - `handlers/booking/`: –õ–æ–≥–∏–∫–∞, —Å–≤—è–∑–∞–Ω–Ω–∞—è –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ —Å –ø—Ä–æ—Ü–µ—Å—Å–æ–º –∑–∞–ø–∏—Å–∏.
- **`states/`:** –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏–π –¥–ª—è FSM (`aiogram`).
- **`utils/`:** –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–æ–¥—É–ª–∏.
  - `utils/db/database.py`: –û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ–º —Å –ë–î.
  - `utils/db/*_queries.py`: –ú–æ–¥—É–ª–∏ —Å SQL-–∑–∞–ø—Ä–æ—Å–∞–º–∏ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π (–∑–∞–ø–∏—Å–∏, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏).
- **`templates/`:** JSON-—Ñ–∞–π–ª—ã —Å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è–º–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –±–∏–∑–Ω–µ—Å–∞. –≠—Ç–∏ —Ñ–∞–π–ª—ã —Å–æ–¥–µ—Ä–∂–∞—Ç –≤—Å—ë: –æ—Ç –Ω–∞–∑–≤–∞–Ω–∏—è –∏ —É—Å–ª—É–≥ –¥–æ —Ç–µ–∫—Å—Ç–æ–≤ —Å–æ–æ–±—â–µ–Ω–∏–π.

## 5. –í–∞–∂–Ω—ã–µ –∞—Å–ø–µ–∫—Ç—ã

- **–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è:** –ë–æ—Ç —è–≤–ª—è–µ—Ç—Å—è "–∫–æ—Ä–æ–±–æ—á–Ω—ã–º" —Ä–µ—à–µ–Ω–∏–µ–º. –í—Å—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ (—É—Å–ª—É–≥–∏, –º–∞—Å—Ç–µ—Ä–∞, —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ, —Ç–µ–∫—Å—Ç—ã) –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è —á–µ—Ä–µ–∑ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ JSON-—Ñ–∞–π–ª–æ–≤ –≤ –ø–∞–ø–∫–µ `templates/`. –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –±—ã—Å—Ç—Ä–æ –∑–∞–ø—É—Å–∫–∞—Ç—å –±–æ—Ç–æ–≤ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–æ–¥–∞.
- **–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö:** –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å –ë–î –¥–æ–ª–∂–Ω–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç—å –ò–°–ö–õ–Æ–ß–ò–¢–ï–õ–¨–ù–û —á–µ—Ä–µ–∑ `DatabaseManager`, –∫–æ—Ç–æ—Ä—ã–π –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è –≤ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏. –≠—Ç–æ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º–∏ –∏ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –æ—à–∏–±–∫–∏.
- **–°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å:** –ü—Ä–æ–µ–∫—Ç —Ç—Ä–µ–±—É–µ—Ç –≤—ã—Å–æ–∫–æ–π –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏. –û—Å–æ–±–æ–µ –≤–Ω–∏–º–∞–Ω–∏–µ —É–¥–µ–ª—è–µ—Ç—Å—è –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ—à–∏–±–æ–∫ –∏ –∫—Ä–∞–π–Ω–∏—Ö —Å–ª—É—á–∞–µ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, "—Å–æ—Å—Ç–æ—è–Ω–∏–µ –≥–æ–Ω–∫–∏" –ø—Ä–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–º –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–∏).
=== FILE: .docs/PROJECT_STATE.md ===
# Project State

| File Path | Status | Last Modified (Session) | Notes |
|:---|:---|:---|:---|
| `handlers/booking/confirmation.py` | **Verified & Patched** | 2024-05-21 | Added `try-except` block to handle race conditions and other errors. Improved user feedback. |
| `templates/beauty_salon.json` | **Verified & Modified** | 2024-05-21 | Updated the `slot_taken` error message for better clarity. |
| `utils/db/booking_queries.py` | **Verified** | 2024-05-21 | Code reviewed. Confirmed that the database layer correctly uses transactions to prevent double booking and raises a `ValueError`. No changes were needed. |
| `handlers/start.py` | **Rolled Back** | 2024-05-21 | Initial changes were reverted as they were not aligned with the user's immediate priority. |

=== FILE: .docs/README.md ===
# –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –¥–ª—è AI

=== FILE: admin_bot/main.py ===
#!/usr/bin/env python3
"""
BOT-BUSINESS V2.0 - –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å
–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–∫–∞–∑–∞–º–∏, –∫–ª–∏–µ–Ω—Ç–∞–º–∏, —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π
"""

import argparse
import asyncio
import logging
import os
import sys

from dotenv import load_dotenv

load_dotenv()

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.fsm.storage.memory import MemoryStorage

from utils.db import DatabaseManager
from utils.config_loader import load_config  # –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ò–ú–ü–û–†–¢
from utils.logger import setup_logger

from admin_bot.middleware import (
    AdminAuthMiddleware,
    AdminPinMiddleware,
    ConfigMiddleware,
    PinMiddlewareInjector,
)
from admin_bot.handlers import setup_handlers

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º admin handlers (—Ä–æ—É—Ç–µ—Ä—ã)
from admin_handlers import (
    services_editor,
    settings_editor,
    business_settings,
    texts_editor,
    notifications_editor,
    staff_editor,
    promotions_editor,
)


async def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∞–¥–º–∏–Ω-–±–æ—Ç–∞"""
    parser = argparse.ArgumentParser(description='Admin Bot for Bot-Business V2.0')
    # –ê—Ä–≥—É–º–µ–Ω—Ç –∏–∑–º–µ–Ω–µ–Ω –Ω–∞ --config-dir –¥–ª—è –µ–¥–∏–Ω–æ–æ–±—Ä–∞–∑–∏—è —Å main.py
    parser.add_argument('--config-dir', type=str, default='config', help='Path to config directory')
    args = parser.parse_args()

    # –ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
    try:
        config = load_config(args.config_dir)
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ª–æ–≥–≥–µ—Ä–∞ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ñ–∏–≥–∞
        logger = setup_logger(config['business_slug'], 'admin_bot')
        logger.info(f"‚úÖ Config loaded: {config.get('business_name')}")
    except Exception as e:
        logging.critical(f"‚ùå Failed to load config from '{args.config_dir}': {e}", exc_info=True)
        return

    # –¢–æ–∫–µ–Ω –∞–¥–º–∏–Ω-–±–æ—Ç–∞
    admin_token = os.getenv('ADMIN_BOT_TOKEN')
    if not admin_token:
        logger.error("‚ùå ADMIN_BOT_TOKEN not found in .env!")
        return

    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î
    db_manager = DatabaseManager(config['business_slug'])
    try:
        logger.info(f"‚úÖ Database ready: db_{config['business_slug']}.sqlite")
    except Exception as e:
        logger.error(f"‚ùå Database error: {e}")
        return

    # –°–æ–∑–¥–∞—ë–º –±–æ—Ç–∞ –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä
    bot = Bot(token=admin_token, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
    storage = MemoryStorage()
    dp = Dispatcher(storage=storage)

    # –ü–æ–¥–∫–ª—é—á–∞–µ–º middlewares
    # –£–î–ê–õ–ï–ù–û: config_manager –±–æ–ª—å—à–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è
    dp.update.middleware(ConfigMiddleware(config, db_manager))
    dp.update.middleware(AdminAuthMiddleware(config))
    pin_middleware = AdminPinMiddleware(config)
    dp.update.middleware(pin_middleware)
    dp.update.middleware(PinMiddlewareInjector(pin_middleware))

    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º handlers –∏–∑ –º–æ–¥—É–ª–µ–π
    setup_handlers(dp, pin_middleware)

    # –ü–æ–¥–∫–ª—é—á–∞–µ–º —Ä–æ—É—Ç–µ—Ä—ã –∏–∑ admin_handlers
    dp.include_router(services_editor.router)
    dp.include_router(settings_editor.router)
    dp.include_router(business_settings.router)
    dp.include_router(texts_editor.router)
    dp.include_router(notifications_editor.router)
    dp.include_router(staff_editor.router)
    dp.include_router(promotions_editor.router)

    logger.info(f"üöÄ Admin Bot for '{config.get('business_name')}' started!")

    try:
        await bot.delete_webhook(drop_pending_updates=True)
        await dp.start_polling(bot)
    except KeyboardInterrupt:
        logger.info("Received KeyboardInterrupt")
    except Exception as e:
        logger.error(f"‚ùå Error: {e}")
    finally:
        db_manager.close()
        await bot.session.close()
        logger.info("üõë Admin Bot stopped")


if __name__ == '__main__':
    asyncio.run(main())

=== FILE: configs/client_lite.json ===
{
  "config_version": 1,
  "bot_token": "FROM_ENV",
  "business_slug": "mini_studio",
  "business_name": "–°—Ç—É–¥–∏—è –∫—Ä–∞—Å–æ—Ç—ã \"–®–∞—Ä–º\"",
  "admin_ids": [
    5122428712
  ],
  "industry": "beauty",
  "contacts": {
    "address": "–≥. –ú–æ—Å–∫–≤–∞, —É–ª. –¶–≤–µ—Ç–æ—á–Ω–∞—è, –¥. 15",
    "phone": "+7 (495) 123-45-67"
  },
  "services": [
    {
      "id": "hair_women_cut",
      "name": "–ñ–µ–Ω—Å–∫–∞—è —Å—Ç—Ä–∏–∂–∫–∞",
      "price": 1800,
      "duration": 60,
      "category": "–í–æ–ª–æ—Å—ã"
    },
    {
      "id": "hair_men_cut",
      "name": "–ú—É–∂—Å–∫–∞—è —Å—Ç—Ä–∏–∂–∫–∞",
      "price": 1200,
      "duration": 45,
      "category": "–í–æ–ª–æ—Å—ã"
    },
    {
      "id": "hair_coloring",
      "name": "–û–∫—Ä–∞—à–∏–≤–∞–Ω–∏–µ –≤–æ–ª–æ—Å",
      "price": 4000,
      "duration": 120,
      "category": "–í–æ–ª–æ—Å—ã"
    },
    {
      "id": "hair_styling",
      "name": "–£–∫–ª–∞–¥–∫–∞",
      "price": 1500,
      "duration": 45,
      "category": "–í–æ–ª–æ—Å—ã"
    },
    {
      "id": "nails_manicure",
      "name": "–ú–∞–Ω–∏–∫—é—Ä –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π",
      "price": 1500,
      "duration": 60,
      "category": "–ù–æ–≥—Ç–∏"
    },
    {
      "id": "nails_gel",
      "name": "–ú–∞–Ω–∏–∫—é—Ä —Å –≥–µ–ª—å-–ª–∞–∫–æ–º",
      "price": 2200,
      "duration": 90,
      "category": "–ù–æ–≥—Ç–∏"
    },
    {
      "id": "nails_pedicure",
      "name": "–ü–µ–¥–∏–∫—é—Ä",
      "price": 2500,
      "duration": 90,
      "category": "–ù–æ–≥—Ç–∏"
    },
    {
      "id": "brows_correction",
      "name": "–ö–æ—Ä—Ä–µ–∫—Ü–∏—è –±—Ä–æ–≤–µ–π",
      "price": 900,
      "duration": 30,
      "category": "–ë—Ä–æ–≤–∏ –∏ —Ä–µ—Å–Ω–∏—Ü—ã"
    },
    {
      "id": "brows_lamination",
      "name": "–õ–∞–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –±—Ä–æ–≤–µ–π",
      "price": 2200,
      "duration": 60,
      "category": "–ë—Ä–æ–≤–∏ –∏ —Ä–µ—Å–Ω–∏—Ü—ã"
    },
    {
      "id": "lash_extension",
      "name": "–ù–∞—Ä–∞—â–∏–≤–∞–Ω–∏–µ —Ä–µ—Å–Ω–∏—Ü",
      "price": 3500,
      "duration": 120,
      "category": "–ë—Ä–æ–≤–∏ –∏ —Ä–µ—Å–Ω–∏—Ü—ã"
    },
    {
      "id": "face_cleaning",
      "name": "–ß–∏—Å—Ç–∫–∞ –ª–∏—Ü–∞",
      "price": 3500,
      "duration": 75,
      "category": "–ö–æ—Å–º–µ—Ç–æ–ª–æ–≥–∏—è"
    },
    {
      "id": "face_peeling",
      "name": "–ü–∏–ª–∏–Ω–≥",
      "price": 2500,
      "duration": 45,
      "category": "–ö–æ—Å–º–µ—Ç–æ–ª–æ–≥–∏—è"
    },
    {
      "id": "combo_cut_styling",
      "name": "–°—Ç—Ä–∏–∂–∫–∞ + —É–∫–ª–∞–¥–∫–∞",
      "price": 2800,
      "duration": 90,
      "category": "–ö–æ–º–ø–ª–µ–∫—Å–Ω—ã–µ —É—Å–ª—É–≥–∏"
    },
    {
      "id": "combo_mani_pedi",
      "name": "–ú–∞–Ω–∏–∫—é—Ä + –ø–µ–¥–∏–∫—é—Ä",
      "price": 4200,
      "duration": 150,
      "category": "–ö–æ–º–ø–ª–µ–∫—Å–Ω—ã–µ —É—Å–ª—É–≥–∏"
    },
    {
      "id": "combo_brows_lash",
      "name": "–ë—Ä–æ–≤–∏ + —Ä–µ—Å–Ω–∏—Ü—ã",
      "price": 5000,
      "duration": 150,
      "category": "–ö–æ–º–ø–ª–µ–∫—Å–Ω—ã–µ —É—Å–ª—É–≥–∏"
    }
  ],
  "booking": {
    "work_start": 10,
    "work_end": 21,
    "slot_duration": 30,
    "timezone": "Europe/Moscow"
  },
  "timezone_city": "–ú–æ—Å–∫–≤–∞",
  "timezone_offset_hours": 3,
  "faq": [
    {
      "btn": "üïí –ß–∞—Å—ã —Ä–∞–±–æ—Ç—ã",
      "answer": "–ü–Ω‚Äì–ü—Ç: 10:00‚Äì21:00\n–°–±‚Äì–í—Å: 10:00‚Äì20:00"
    },
    {
      "btn": "üìû –ö–æ–Ω—Ç–∞–∫—Ç—ã",
      "answer": "‚òéÔ∏è +7 (495) 123-45-67"
    },
    {
      "btn": "üí≥ –°–ø–æ—Å–æ–±—ã –æ–ø–ª–∞—Ç—ã",
      "answer": "–ü—Ä–∏–Ω–∏–º–∞–µ–º –Ω–∞–ª–∏—á–Ω—ã–µ –∏ –±–∞–Ω–∫–æ–≤—Å–∫–∏–µ –∫–∞—Ä—Ç—ã."
    },
    {
      "btn": "‚ùì –ö–∞–∫ –æ—Ç–º–µ–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å",
      "answer": "–ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ ¬´üìã –ú–æ–∏ –∑–∞–ø–∏—Å–∏¬ª –∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –æ—Ç–º–µ–Ω—ã."
    }
  ],
  "features": {
    "enable_slot_booking": true,
    "enable_admin_notify": true,
    "require_phone": true,
    "ask_comment": true
  },
  "messages": {
    "welcome": "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Å—Ç—É–¥–∏—é –∫—Ä–∞—Å–æ—Ç—ã ¬´–®–∞—Ä–º¬ª!\n\n–ó–∞–ø–∏—à–∏—Ç–µ—Å—å –∫ –Ω–∞—à–∏–º –º–∞—Å—Ç–µ—Ä–∞–º –∑–∞ 30 —Å–µ–∫—É–Ω–¥.",
    "success": "‚úÖ –ó–∞–ø–∏—Å—å ‚Ññ{id} –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞!\n–ñ–¥—ë–º –≤–∞—Å {date} –≤ {time}.",
    "booking_cancelled": "‚ùå –ó–∞–ø–∏—Å—å –æ—Ç–º–µ–Ω–µ–Ω–∞. –ù–∞–¥–µ–µ–º—Å—è —É–≤–∏–¥–µ—Ç—å –≤–∞—Å —Å–Ω–æ–≤–∞!",
    "error_phone": "‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –Ω–æ–º–µ—Ä. –í–≤–µ–¥–∏—Ç–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ +79991234567",
    "error_generic": "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
    "slot_taken": "‚ùå –≠—Ç–æ –≤—Ä–µ–º—è —É–∂–µ –∑–∞–Ω—è—Ç–æ"
  },
  "staff": {
    "enabled": true,
    "masters": [
      {
        "id": "master_anna",
        "name": "–ê–Ω–Ω–∞",
        "specialization": "–ü–∞—Ä–∏–∫–º–∞—Ö–µ—Ä-—Å—Ç–∏–ª–∏—Å—Ç",
        "active": true,
        "services": [
          "hair_women_cut",
          "hair_men_cut",
          "hair_coloring",
          "hair_styling",
          "combo_cut_styling"
        ],
        "schedule": {
          "monday": {
            "working": true,
            "start": "10:00",
            "end": "19:00"
          },
          "tuesday": {
            "working": true,
            "start": "10:00",
            "end": "19:00"
          },
          "wednesday": {
            "working": true,
            "start": "10:00",
            "end": "19:00"
          },
          "thursday": {
            "working": true,
            "start": "10:00",
            "end": "19:00"
          },
          "friday": {
            "working": true,
            "start": "10:00",
            "end": "19:00"
          },
          "saturday": {
            "working": true,
            "start": "10:00",
            "end": "18:00"
          },
          "sunday": {
            "working": false
          }
        },
        "closed_dates": []
      },
      {
        "id": "master_maria",
        "name": "–ú–∞—Ä–∏—è",
        "specialization": "–ú–∞—Å—Ç–µ—Ä –º–∞–Ω–∏–∫—é—Ä–∞",
        "active": true,
        "services": [
          "nails_manicure",
          "nails_gel",
          "nails_pedicure",
          "combo_mani_pedi"
        ],
        "schedule": {
          "monday": {
            "working": false
          },
          "tuesday": {
            "working": true,
            "start": "10:00",
            "end": "20:00"
          },
          "wednesday": {
            "working": true,
            "start": "10:00",
            "end": "20:00"
          },
          "thursday": {
            "working": true,
            "start": "10:00",
            "end": "20:00"
          },
          "friday": {
            "working": true,
            "start": "10:00",
            "end": "20:00"
          },
          "saturday": {
            "working": true,
            "start": "10:00",
            "end": "18:00"
          },
          "sunday": {
            "working": false
          }
        },
        "closed_dates": []
      },
      {
        "id": "master_elena",
        "name": "–ï–ª–µ–Ω–∞",
        "specialization": "–ë—Ä–æ–≤–∏—Å—Ç",
        "active": true,
        "services": [
          "brows_correction",
          "brows_lamination",
          "lash_extension",
          "combo_brows_lash"
        ],
        "schedule": {
          "monday": {
            "working": true,
            "start": "11:00",
            "end": "20:00"
          },
          "tuesday": {
            "working": true,
            "start": "11:00",
            "end": "20:00"
          },
          "wednesday": {
            "working": false
          },
          "thursday": {
            "working": true,
            "start": "11:00",
            "end": "20:00"
          },
          "friday": {
            "working": true,
            "start": "11:00",
            "end": "20:00"
          },
          "saturday": {
            "working": true,
            "start": "10:00",
            "end": "18:00"
          },
          "sunday": {
            "working": true,
            "start": "10:00",
            "end": "16:00"
          }
        },
        "closed_dates": []
      },
      {
        "id": "master_olga",
        "name": "–û–ª—å–≥–∞",
        "specialization": "–ö–æ—Å–º–µ—Ç–æ–ª–æ–≥",
        "active": true,
        "services": [
          "face_cleaning",
          "face_peeling"
        ],
        "schedule": {
          "monday": {
            "working": true,
            "start": "10:00",
            "end": "18:00"
          },
          "tuesday": {
            "working": false
          },
          "wednesday": {
            "working": true,
            "start": "10:00",
            "end": "18:00"
          },
          "thursday": {
            "working": false
          },
          "friday": {
            "working": true,
            "start": "10:00",
            "end": "18:00"
          },
          "saturday": {
            "working": true,
            "start": "10:00",
            "end": "16:00"
          },
          "sunday": {
            "working": false
          }
        },
        "closed_dates": []
      }
    ]
  }
}
=== FILE: handlers/booking/__init__.py ===
"""
–°–æ–±–∏—Ä–∞–µ—Ç –≤—Å–µ —Ä–æ—É—Ç–µ—Ä—ã –∏–∑ –º–æ–¥—É–ª—è booking –≤ –æ–¥–∏–Ω.
"""

from aiogram import Router

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ä–æ—É—Ç–µ—Ä—ã –∏–∑ –≤—Å–µ—Ö —á–∞—Å—Ç–µ–π –ø—Ä–æ—Ü–µ—Å—Å–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
from .router_nav import router as nav_router
from .category import router as category_router
from .service import router as service_router
from .master import router as master_router
from .date import router as date_router
from .time import router as time_router
from .contact import router as contact_router
from .confirmation import router as confirmation_router

# –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —Ä–æ—É—Ç–µ—Ä—ã –≤ –æ–¥–∏–Ω, —á—Ç–æ–±—ã –ø–æ–¥–∫–ª—é—á–∏—Ç—å –≤ –≥–ª–∞–≤–Ω–æ–º __init__.py
all_booking_routers = Router()

all_booking_routers.include_router(nav_router)
all_booking_routers.include_router(category_router)
all_booking_routers.include_router(service_router)
all_booking_routers.include_router(master_router)
all_booking_routers.include_router(date_router)
all_booking_routers.include_router(time_router)
all_booking_routers.include_router(contact_router)
all_booking_routers.include_router(confirmation_router)

=== FILE: handlers/booking/category.py ===
"""
–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ —Å—Ç–∞—Ä—Ç–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è.
"""

import logging
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext

from states.booking import BookingState
from .keyboards import get_categories_keyboard
from .service import show_services_list

logger = logging.getLogger(__name__)

router = Router()

async def start_booking_flow(callback_or_message: Message | CallbackQuery, state: FSMContext, config: dict):
    """–ù–∞—á–∏–Ω–∞–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è, –ø–æ–∫–∞–∑—ã–≤–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏–ª–∏ —Å—Ä–∞–∑—É —É—Å–ª—É–≥–∏."""
    categories = config.get('categories', [])
    message = callback_or_message if isinstance(callback_or_message, Message) else callback_or_message.message

    if categories:
        await message.answer(
            text=config.get('messages', {}).get('category_selection', "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:"),
            reply_markup=get_categories_keyboard(categories)
        )
        await state.set_state(BookingState.choosing_service)
    else:
        # –ï—Å–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π –Ω–µ—Ç, —Å—Ä–∞–∑—É –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —É—Å–ª—É–≥–∏
        await show_services_list(callback_or_message, state, config)

@router.callback_query(BookingState.choosing_service, F.data.startswith("cat:"))
async def category_selected(callback: CallbackQuery, state: FSMContext, config: dict):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—ã–±–æ—Ä –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —É—Å–ª—É–≥ –≤ –Ω–µ–π."""
    category_name = callback.data.split(":")[1]
    await state.update_data(category_name=category_name)
    await show_services_list(callback, state, config, category_name)
    await callback.answer()

=== FILE: handlers/booking/confirmation.py ===
"""
–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∑–∞–ø–∏—Å–∏.
"""

import logging
from datetime import datetime
from aiogram import Router, F, Bot
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.context import FSMContext

from states.booking import BookingState

logger = logging.getLogger(__name__)

router = Router()

async def show_confirmation(message: Message, state: FSMContext):
    """–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç —Å–≤–æ–¥–∫—É –ø–æ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—é –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è."""
    data = await state.get_data()
    booking_datetime = datetime.fromisoformat(data.get('booking_datetime'))
    
    summary_text = (
        f"<b>–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –≤–∞—à—É –∑–∞–ø–∏—Å—å:</b>\n\n"
        f"<b>–£—Å–ª—É–≥–∞:</b> {data.get('service_name')}\n"
        f"<b>–ú–∞—Å—Ç–µ—Ä:</b> {data.get('master_name', '–õ—é–±–æ–π')}\n"
        f"<b>–î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è:</b> {booking_datetime.strftime('%d.%m.%Y –≤ %H:%M')}\n"
        f"<b>–¶–µ–Ω–∞:</b> {data.get('price')}\n\n"
        f"<b>–í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ:</b>\n"
        f"<b>–ò–º—è:</b> {data.get('name')}\n"
        f"<b>–¢–µ–ª–µ—Ñ–æ–Ω:</b> {data.get('phone')}\n"
    )
    if data.get('comment'):
        summary_text += f"<b>–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:</b> {data.get('comment')}\n"

    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∏ –∑–∞–ø–∏—Å–∞—Ç—å—Å—è", callback_data="confirm_booking")],
        [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∏—Ç—å", callback_data="cancel_booking_process")]
    ])
    
    await message.answer(summary_text, reply_markup=keyboard)
    await state.set_state(BookingState.confirmation)

@router.callback_query(BookingState.confirmation, F.data == "confirm_booking")
async def confirm_booking_callback(callback: CallbackQuery, state: FSMContext, db_manager, config: dict, admin_bot: Bot):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ –ë–î, —É–≤–µ–¥–æ–º–ª—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞."""
    user_id = callback.from_user.id
    data = await state.get_data()
    
    try:
        booking_id = db_manager.create_booking(
            user_id=user_id,
            service_id=data.get('service_id'),
            service_name=data.get('service_name'),
            master_id=data.get('master_id'),
            master_name=data.get('master_name'),
            booking_datetime=data.get('booking_datetime'),
            price=data.get('price'),
            comment=data.get('comment')
        )

        if not booking_id:
            raise ValueError("Booking creation returned no ID")

        logger.info(f"User {user_id} confirmed booking {booking_id}")

        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Å–ø–µ—Ö–µ
        success_template = config.get('messages', {}).get('success', "‚úÖ –ó–∞–ø–∏—Å—å ‚Ññ{id} –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞!")
        booking_datetime = datetime.fromisoformat(data.get('booking_datetime'))
        
        format_data = {
            'id': booking_id,
            'date': booking_datetime.strftime('%d.%m.%Y'),
            'time': booking_datetime.strftime('%H:%M'),
            'address': config.get('contacts', {}).get('address', ''),
            'business_name': config.get('business_name', '')
        }
        
        success_message = success_template.format(**format_data)
        await callback.message.edit_text(success_message)

        # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ (–µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ)
        await notify_admin_on_booking(callback, data, booking_id, config, admin_bot)

    except ValueError:
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏—Ç—É–∞—Ü–∏–∏, –∫–æ–≥–¥–∞ —Å–ª–æ—Ç —É–∂–µ –∑–∞–Ω—è—Ç (race condition)
        logger.warning(f"User {user_id} tried to book an already taken slot.")
        error_msg = config.get('messages', {}).get('slot_taken', "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —ç—Ç–æ –≤—Ä–µ–º—è —É–∂–µ –∑–∞–Ω—è—Ç–æ.")
        await callback.message.edit_text(error_msg, reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="‚óÄÔ∏è –í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–µ –≤—Ä–µ–º—è", callback_data="back_to_time_selection")]
        ]))
    
    except Exception as e:
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥—Ä—É–≥–∏—Ö –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω—ã—Ö –æ—à–∏–±–æ–∫
        logger.error(f"An unexpected error occurred during booking confirmation: {e}", exc_info=True)
        error_msg = config.get('messages', {}).get('error_generic', "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏.")
        await callback.message.edit_text(error_msg)

    finally:
        # –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ç–æ–ª—å–∫–æ –≤ —Å–ª—É—á–∞–µ —É—Å–ø–µ—Ö–∞ –∏–ª–∏ –ø–æ–ª–Ω–æ–π –æ—Ç–º–µ–Ω—ã
        if 'booking_id' in locals() and booking_id:
            await state.clear()
        await callback.answer()

async def notify_admin_on_booking(callback: CallbackQuery, data: dict, booking_id: int, config: dict, admin_bot: Bot):
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞–º –æ –Ω–æ–≤–æ–π –∑–∞–ø–∏—Å–∏."""
    admin_ids = config.get('admin_ids', [])
    if not admin_ids:
        return

    notification_bot = admin_bot if admin_bot else callback.bot
    user = callback.from_user
    user_mention = f"@{user.username}" if user.username else user.full_name
    booking_datetime = datetime.fromisoformat(data.get('booking_datetime'))

    admin_text = (
        f"üîî <b>–ù–û–í–ê–Ø –ó–ê–ü–ò–°–¨</b> üîî\n\n"
        f"<b>–ö–ª–∏–µ–Ω—Ç:</b> {data.get('name')}, {user_mention} (ID: `{user.id}`)\n"
        f"<b>–¢–µ–ª–µ—Ñ–æ–Ω:</b> `{data.get('phone')}`\n\n"
        f"<b>–£—Å–ª—É–≥–∞:</b> {data.get('service_name')}\n"
        f"<b>–ú–∞—Å—Ç–µ—Ä:</b> {data.get('master_name', '–õ—é–±–æ–π')}\n"
        f"<b>–î–∞—Ç–∞ –∏ –≤—Ä–µ–º—è:</b> {booking_datetime.strftime('%d.%m.%Y –≤ %H:%M')}\n"
    )
    if data.get('comment'):
        admin_text += f"<b>–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:</b> {data.get('comment')}\n"
    
    try:
        for admin_id in admin_ids:
            await notification_bot.send_message(admin_id, admin_text)
    except Exception as e:
        logger.error(f"Failed to send booking notification to admin {admin_id}: {e}")


@router.callback_query(BookingState.confirmation, F.data == "cancel_booking_process")
async def cancel_booking_process_callback(callback: CallbackQuery, state: FSMContext, config: dict):
    """–û—Ç–º–µ–Ω—è–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ —ç—Ç–∞–ø–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è."""
    await state.clear()
    cancel_message = config.get('messages', {}).get('booking_cancelled', "–ó–∞–ø–∏—Å—å –æ—Ç–º–µ–Ω–µ–Ω–∞.")
    await callback.message.edit_text(cancel_message)
    await callback.answer()

=== FILE: handlers/booking/contact.py ===
"""
–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –≤–≤–æ–¥–∞ –∫–æ–Ω—Ç–∞–∫—Ç–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.
"""

import logging
from aiogram import Router, F
from aiogram.types import Message
from aiogram.fsm.context import FSMContext

from states.booking import BookingState
from .confirmation import show_confirmation

logger = logging.getLogger(__name__)

router = Router()

async def request_contact_info(callback_or_message, state: FSMContext, db_manager):
    """Asks the user for their name and phone number."""
    message = callback_or_message if isinstance(callback_or_message, Message) else callback_or_message.message
    user_id = message.from_user.id
    
    # Check if user contact info already exists in the database
    user_info = db_manager.get_user_contact_info(user_id)
    
    if user_info and user_info.get('name') and user_info.get('phone'):
        await state.update_data(name=user_info['name'], phone=user_info['phone'])
        await show_confirmation(message, state)
    else:
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –∏–º—è:")
        await state.set_state(BookingState.input_name)

@router.message(BookingState.input_name, F.text)
async def name_entered(message: Message, state: FSMContext):
    """Handles the user entering their name."""
    await state.update_data(name=message.text)
    logger.info(f"User {message.from_user.id} entered name: {message.text}")
    await message.answer("–¢–µ–ø–µ—Ä—å, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, +79123456789):")
    await state.set_state(BookingState.input_phone)

@router.message(BookingState.input_phone, F.text)
async def phone_entered(message: Message, state: FSMContext, db_manager):
    """Handles the user entering their phone number."""
    # Basic validation could be added here
    await state.update_data(phone=message.text)
    logger.info(f"User {message.from_user.id} entered phone: {message.text}")
    
    # Save/update user contact info in the database
    user_id = message.from_user.id
    data = await state.get_data()
    db_manager.update_user_contact_info(user_id, data.get('name'), data.get('phone'))

    await message.answer("–í—ã —Ö–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –∑–∞–ø–∏—Å–∏? (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)")
    await state.set_state(BookingState.input_comment)

@router.message(BookingState.input_comment, F.text)
async def comment_entered(message: Message, state: FSMContext):
    """Handles the user entering a comment."""
    await state.update_data(comment=message.text)
    logger.info(f"User {message.from_user.id} entered comment: {message.text}")
    await show_confirmation(message, state)

=== FILE: handlers/booking/date.py ===
"""
–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ –¥–∞—Ç—ã.
"""

import logging
from datetime import date, timedelta
from aiogram import Router, F
from aiogram.types import CallbackQuery, Message
from aiogram.fsm.context import FSMContext

from states.booking import BookingState
from ..keyboards import get_calendar_keyboard # assuming keyboards are in handlers/booking/keyboards.py
from .time import show_time_slots

logger = logging.getLogger(__name__)

router = Router()

async def proceed_to_date_selection(callback_or_message, state: FSMContext, config: dict, service: dict):
    """Displays the calendar for date selection."""
    today = date.today()
    
    # Decide if we're editing a message or sending a new one
    message = callback_or_message if isinstance(callback_or_message, Message) else callback_or_message.message

    keyboard = get_calendar_keyboard(year=today.year, month=today.month)
    await message.edit_text(f"üìÖ –í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É –¥–ª—è —É—Å–ª—É–≥–∏ ¬´{service['name']}¬ª:", reply_markup=keyboard)
    await state.set_state(BookingState.choosing_date)

@router.callback_query(BookingState.choosing_date, F.data.startswith("calendar:"))
async def calendar_callback_handler(callback: CallbackQuery, state: FSMContext, db_manager, config: dict):
    """Handles calendar navigation and date selection."""
    action, year_str, month_str, day_str = callback.data.split(':')
    year, month, day = int(year_str), int(month_str), int(day_str)

    if action == "ignore":
        await callback.answer()
        return

    if action == "prev-month":
        prev_month_date = date(year, month, 1) - timedelta(days=1)
        keyboard = get_calendar_keyboard(year=prev_month_date.year, month=prev_month_date.month)
        await callback.message.edit_reply_markup(reply_markup=keyboard)
        await callback.answer()
        return

    if action == "next-month":
        next_month_date = date(year, month, 1) + timedelta(days=31)
        keyboard = get_calendar_keyboard(year=next_month_date.year, month=next_month_date.month)
        await callback.message.edit_reply_markup(reply_markup=keyboard)
        await callback.answer()
        return

    if action == "select-day":
        selected_date = date(year, month, day)
        today = date.today()
        if selected_date < today:
            await callback.answer("–ù–µ–ª—å–∑—è –≤—ã–±—Ä–∞—Ç—å –ø—Ä–æ—à–µ–¥—à—É—é –¥–∞—Ç—É!", show_alert=True)
            return
        
        await state.update_data(booking_date=selected_date.isoformat())
        logger.info(f"User {callback.from_user.id} selected date: {selected_date.isoformat()}")
        
        # Proceed to time selection
        await show_time_slots(callback, state, config, db_manager, selected_date)
        await callback.answer()

=== FILE: handlers/booking/keyboards.py ===
"""
–§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é.
"""

from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton
from calendar import monthcalendar
from datetime import date

def get_main_keyboard() -> ReplyKeyboardMarkup:
    """–°–æ–∑–¥–∞–Ω–∏–µ –≥–ª–∞–≤–Ω–æ–π –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã —Å –Ω–∞–≤–∏–≥–∞—Ü–∏–µ–π"""
    buttons = [
        [
            KeyboardButton(text="üìÖ –ó–∞–ø–∏—Å–∞—Ç—å—Å—è"),
            KeyboardButton(text="üìã –ú–æ–∏ –∑–∞–ø–∏—Å–∏")
        ],
        [
            KeyboardButton(text="üíÖ –£—Å–ª—É–≥–∏ –∏ —Ü–µ–Ω—ã"),
            KeyboardButton(text="üë©‚Äçüé® –ú–∞—Å—Ç–µ—Ä–∞")
        ],
        [
            KeyboardButton(text="üéÅ –ê–∫—Ü–∏–∏"),
            KeyboardButton(text="‚ÑπÔ∏è –û –Ω–∞—Å")
        ],
        [
            KeyboardButton(text="‚ùì FAQ"),
            KeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥"),
        ],
    ]

    return ReplyKeyboardMarkup(
        keyboard=buttons,
        resize_keyboard=True
    )

def get_info_keyboard(add_booking_button: bool = True) -> InlineKeyboardMarkup:
    """–°–æ–∑–¥–∞–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é inline-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ä–∞–∑–¥–µ–ª–æ–≤."""
    buttons = []
    if add_booking_button:
        buttons.append([InlineKeyboardButton(text="üìÖ –ó–∞–ø–∏—Å–∞—Ç—å—Å—è", callback_data="start_booking")])
    buttons.append([InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_main_menu")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)

def get_categories_keyboard(categories: list) -> InlineKeyboardMarkup:
    """Creates a keyboard with service categories."""
    buttons = []
    for category in categories:
        buttons.append([InlineKeyboardButton(text=category, callback_data=f"cat:{category}")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)

def get_services_keyboard(services: list, category_name: str = None) -> InlineKeyboardMarkup:
    """Creates a keyboard with services."""
    buttons = []
    for service in services:
        button_text = f"{service['name']} - {service['price']}"
        buttons.append([InlineKeyboardButton(text=button_text, callback_data=f"srv:{service['id']}")])
    # Add a back button if inside a category
    if category_name:
        buttons.append([InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º", callback_data="back_to_categories")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)

def get_masters_keyboard(masters: list) -> InlineKeyboardMarkup:
    """Creates a keyboard for selecting a master."""
    buttons = []
    for master in masters:
        buttons.append([InlineKeyboardButton(text=master['name'], callback_data=f"master:{master['id']}")])
    buttons.append([InlineKeyboardButton(text="–õ—é–±–æ–π —Å–≤–æ–±–æ–¥–Ω—ã–π –º–∞—Å—Ç–µ—Ä", callback_data="master:any")])
    # Add a back button to go back to service selection
    buttons.append([InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ —É—Å–ª—É–≥–∞–º", callback_data="back_to_services")])
    return InlineKeyboardMarkup(inline_keyboard=buttons)

def get_calendar_keyboard(year: int, month: int) -> InlineKeyboardMarkup:
    """Creates a calendar keyboard for a given month and year."""
    buttons = []
    # Month and year header
    header = date(year, month, 1).strftime('%B %Y')
    buttons.append([InlineKeyboardButton(text=header, callback_data="calendar:ignore:0:0:0")])
    # Day of the week headers
    week_days = ["–ü–Ω", "–í—Ç", "–°—Ä", "–ß—Ç", "–ü—Ç", "–°–±", "–í—Å"]
    buttons.append([InlineKeyboardButton(text=day, callback_data="calendar:ignore:0:0:0") for day in week_days])

    # Calendar days
    month_cal = monthcalendar(year, month)
    for week in month_cal:
        row = []
        for day in week:
            if day == 0:
                row.append(InlineKeyboardButton(text=" ", callback_data="calendar:ignore:0:0:0"))
            else:
                row.append(InlineKeyboardButton(text=str(day), callback_data=f"calendar:select-day:{year}:{month}:{day}"))
        buttons.append(row)

    # Navigation buttons
    nav_row = [
        InlineKeyboardButton(text="<", callback_data=f"calendar:prev-month:{year}:{month}:1"),
        InlineKeyboardButton(text=">", callback_data=f"calendar:next-month:{year}:{month}:1")
    ]
    buttons.append(nav_row)
    
    # Back button
    buttons.append([InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_master_choice")])

    return InlineKeyboardMarkup(inline_keyboard=buttons)

def get_time_slots_keyboard(slots: list) -> InlineKeyboardMarkup:
    """Creates a keyboard with available time slots."""
    buttons = []
    row = []
    for slot in slots:
        row.append(InlineKeyboardButton(text=slot, callback_data=f"time:{slot}"))
        if len(row) == 4: # Adjust number of columns here
            buttons.append(row)
            row = []
    if row: # Add the last row if it's not full
        buttons.append(row)
        
    # Back button
    buttons.append([InlineKeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –≤—ã–±–æ—Ä—É –¥–∞—Ç—ã", callback_data="back_to_date_choice")])

    return InlineKeyboardMarkup(inline_keyboard=buttons)

=== FILE: handlers/booking/master.py ===
"""
–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ –º–∞—Å—Ç–µ—Ä–∞.
"""

import logging
from aiogram import Router, F
from aiogram.types import CallbackQuery
from aiogram.fsm.context import FSMContext

from states.booking import BookingState
from ..keyboards import get_masters_keyboard # assuming keyboards are in handlers/booking/keyboards.py
from ..utils import get_masters_for_service, get_master_by_id # assuming utils are in handlers/booking/utils.py
from .date import proceed_to_date_selection

logger = logging.getLogger(__name__)

router = Router()

async def show_masters_for_service(callback_or_message, state: FSMContext, config: dict, service: dict):
    """Displays the list of masters available for a given service."""
    masters = get_masters_for_service(config, service['id'])
    
    # Decide if we're editing a message or sending a new one
    message = callback_or_message if isinstance(callback_or_message, Message) else callback_or_message.message

    if not masters:
        # No specific masters for this service, skip to date selection
        await state.update_data(master_id=None, master_name=None)
        await proceed_to_date_selection(callback_or_message, state, config, service)
        return

    keyboard = get_masters_keyboard(masters)
    await message.edit_text(f"–í—ã–±–µ—Ä–∏—Ç–µ –º–∞—Å—Ç–µ—Ä–∞ –¥–ª—è —É—Å–ª—É–≥–∏ ¬´{service['name']}¬ª:", reply_markup=keyboard)
    await state.set_state(BookingState.choosing_master)

@router.callback_query(BookingState.choosing_master, F.data.startswith("master:"))
async def master_selected(callback: CallbackQuery, state: FSMContext, config: dict):
    """Handles the selection of a master."""
    master_id = callback.data.split(":", 1)[1]
    
    if master_id == 'any':
        await state.update_data(master_id=None, master_name="–õ—é–±–æ–π")
        master_name = "–õ—é–±–æ–π –º–∞—Å—Ç–µ—Ä"
    else:
        master = get_master_by_id(config, master_id)
        if not master:
            await callback.answer("–ú–∞—Å—Ç–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
            return
        await state.update_data(master_id=master_id, master_name=master['name'])
        master_name = master['name']

    logger.info(f"User {callback.from_user.id} selected master: {master_name}")

    service_id = (await state.get_data()).get('service_id')
    service = next((s for s in config.get('services', []) if s['id'] == service_id), None)

    await proceed_to_date_selection(callback, state, config, service)
    await callback.answer()
=== FILE: handlers/booking/router_nav.py ===
"""
–¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π –º–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ç–æ—Ä –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ "–ù–∞–∑–∞–¥" –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è.
–≠—Ç–æ—Ç –º–æ–¥—É–ª—å —É—Å—Ç—Ä–∞–Ω—è–µ—Ç —Ü–∏–∫–ª–∏—á–µ—Å–∫–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –∏ —Å–∏–ª—å–Ω—É—é —Å–≤—è–∑–∞–Ω–Ω–æ—Å—Ç—å.
"""

import logging
from datetime import datetime
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext

from states.booking import BookingState

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –≤—Å–µ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ —Ä–µ–Ω–¥–µ—Ä—è—Ç —à–∞–≥–∏ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
from .category import start_booking_flow
from .service import show_services_list
from .master import show_masters_for_service
from .date import proceed_to_date_selection
from .time import show_time_slots
from .contact import request_contact_info

logger = logging.getLogger(__name__)
router = Router()

async def get_service_from_data(config: dict, data: dict):
    """–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —É—Å–ª—É–≥–∏ –∏–∑ –¥–∞–Ω–Ω—ã—Ö —Å–æ—Å—Ç–æ—è–Ω–∏—è."""
    service_id = data.get('service_id')
    return next((s for s in config.get('services', []) if s['id'] == service_id), None)

async def navigate_back(callback_or_message: Message | CallbackQuery, state: FSMContext, config: dict, db_manager):
    """
    –ï–¥–∏–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è-–º–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ç–æ—Ä –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –Ω–∞–∑–∞–¥.
    –û–Ω–∞ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –ø—Ä–µ–¥—ã–¥—É—â–∏–π —à–∞–≥ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è FSM.
    """
    current_state = await state.get_state()
    data = await state.get_data()
    message = callback_or_message if isinstance(callback_or_message, Message) else callback_or_message.message

    # –ö–∞—Ä—Ç–∞ —Å–æ—Å—Ç–æ—è–Ω–∏–π –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –Ω–∞–∑–∞–¥
    back_handlers = {
        BookingState.choosing_service: start_booking_flow,
        BookingState.choosing_master: lambda m, s, c, db: show_services_list(m, s, c, data.get('category_name')),
        BookingState.choosing_date: lambda m, s, c, db: show_masters_for_service(m, s, c, get_service_from_data(c, data)),
        BookingState.choosing_time: lambda m, s, c, db: proceed_to_date_selection(m, s, c, get_service_from_data(c, data)),
        BookingState.input_name: lambda m, s, c, db: show_time_slots(m, s, c, db, datetime.fromisoformat(data.get('booking_date')).date()),
        BookingState.input_phone: request_contact_info,
        BookingState.input_comment: request_contact_info,
        BookingState.confirmation: request_contact_info,
    }

    handler = back_handlers.get(current_state)

    if handler:
        # –ê–¥–∞–ø—Ç–∏—Ä—É–µ–º –≤—ã–∑–æ–≤ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–æ–≥–æ, —Ç—Ä–µ–±—É–µ—Ç –ª–∏ –ª—è–º–±–¥–∞ get_service_from_data
        if "lambda" in repr(handler):
             # –ï—Å–ª–∏ —ç—Ç–æ –ª—è–º–±–¥–∞, —Ç–æ –æ–Ω–∞ —É–∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω—É–∂–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑ state
            await handler(message, state, config, db_manager)
        else:
             await handler(message, state, config)
    else:
        # –ï—Å–ª–∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –æ—Ç–º–µ–Ω—è–µ–º –∏ –≤—ã—Ö–æ–¥–∏–º –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
        # –ü—Ä—è–º–æ–π –∏–º–ø–æ—Ä—Ç –∑–∞–º–µ–Ω–µ–Ω –Ω–∞ –ø–æ–ª—É—á–µ–Ω–∏–µ –∏–∑ app-–∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
        from handlers.start import show_main_menu
        await state.clear()
        await show_main_menu(message, config)


# --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è inline-–∫–Ω–æ–ø–æ–∫ "–ù–∞–∑–∞–¥" ---

@router.callback_query(F.data == "back_to_categories")
async def handle_back_to_categories(callback: CallbackQuery, state: FSMContext, config: dict):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∫–Ω–æ–ø–∫–∏ '–ù–∞–∑–∞–¥ –∫ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º'."""
    await start_booking_flow(callback, state, config)
    await callback.answer()

@router.callback_query(F.data == "back_to_services")
async def handle_back_to_services(callback: CallbackQuery, state: FSMContext, config: dict):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∫–Ω–æ–ø–∫–∏ '–ù–∞–∑–∞–¥ –∫ —É—Å–ª—É–≥–∞–º'."""
    data = await state.get_data()
    await show_services_list(callback, state, config, data.get('category_name'))
    await callback.answer()

@router.callback_query(F.data == "back_to_master_choice")
async def handle_back_to_master_choice(callback: CallbackQuery, state: FSMContext, config: dict):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∫–Ω–æ–ø–∫–∏ '–ù–∞–∑–∞–¥ –∫ –≤—ã–±–æ—Ä—É –º–∞—Å—Ç–µ—Ä–∞'."""
    data = await state.get_data()
    service = await get_service_from_data(config, data)
    await show_masters_for_service(callback, state, config, service)
    await callback.answer()

@router.callback_query(F.data == "back_to_date_choice")
async def handle_back_to_date_choice(callback: CallbackQuery, state: FSMContext, config: dict):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∫–Ω–æ–ø–∫–∏ '–ù–∞–∑–∞–¥ –∫ –≤—ã–±–æ—Ä—É –¥–∞—Ç—ã'."""
    data = await state.get_data()
    service = await get_service_from_data(config, data)
    await proceed_to_date_selection(callback, state, config, service)
    await callback.answer()

=== FILE: handlers/booking/save.py ===
"""
–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ –ë–î –∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.
"""

import logging
from datetime import datetime
from aiogram import Router, F
from aiogram.types import CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.context import FSMContext
from states.booking import BookingState
from utils.notify import send_order_to_admins
from .keyboards import get_time_slots_keyboard

logger = logging.getLogger(__name__)

router = Router()

@router.callback_query(BookingState.confirmation, F.data == "confirm_booking")
async def confirm_booking_and_save(callback: CallbackQuery, state: FSMContext, config: dict, db_manager):
    data = await state.get_data()
    if data.get('booking_confirmed'):
        await callback.answer("–ó–∞–ø–∏—Å—å —É–∂–µ —Å–æ–∑–¥–∞–Ω–∞", show_alert=True)
        return

    await state.update_data(booking_confirmed=True)

    try:
        order_id = await save_booking_to_db(data, callback.from_user.id, db_manager)
        db_manager.add_user(user_id=callback.from_user.id, username=callback.from_user.username, first_name=callback.from_user.first_name, last_name=callback.from_user.last_name)
        logger.info(f"Booking confirmed: order_id={order_id}, user_id={callback.from_user.id}")

        await send_success_message(callback, state, config, db_manager, order_id)
        await send_admin_notification(callback, config, data, order_id, db_manager)

        await state.clear()
        await callback.answer("‚úÖ –ó–∞–ø–∏—Å—å —Å–æ–∑–¥–∞–Ω–∞!")

    except ValueError as e:
        logger.warning(f"Slot already taken for user {callback.from_user.id}: {e}")
        await state.update_data(booking_confirmed=False)
        await callback.answer("‚ùå –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —ç—Ç–æ –≤—Ä–µ–º—è —É–∂–µ –∑–∞–Ω—è—Ç–æ. –í—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–µ.", show_alert=True)
        await return_to_time_selection(callback, state, config, db_manager)
    except Exception as e:
        logger.exception(f"Error creating booking for user {callback.from_user.id}: {e}")
        await state.update_data(booking_confirmed=False)
        await callback.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.", show_alert=True)
        await state.clear()

async def save_booking_to_db(data: dict, user_id: int, db_manager) -> int:
    return db_manager.add_order(
        user_id=user_id,
        service_id=data.get('service_id'),
        service_name=data.get('service_name'),
        price=data.get('price'),
        client_name=data.get('client_name'),
        phone=data.get('phone'),
        comment=data.get('comment'),
        booking_date=data.get('booking_date'),
        booking_time=data.get('booking_time'),
        master_id=data.get('master_id')
    )

async def send_success_message(callback: CallbackQuery, state: FSMContext, config: dict, db_manager, order_id: int):
    data = await state.get_data()
    try:
        date_formatted = datetime.fromisoformat(data.get('booking_date')).strftime('%d.%m.%Y')
    except Exception:
        date_formatted = data.get('booking_date')

    success_text = config.get('messages', {}).get('success', "‚úÖ –ó–∞–ø–∏—Å—å #{id} —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!").format(id=order_id, date=date_formatted, time=data.get('booking_time'))
    master_text = f"\nüë§ –ú–∞—Å—Ç–µ—Ä: {data.get('master_name')}" if data.get('master_name') else ""
    await callback.message.edit_text(f"{success_text}\n\nüìÖ {date_formatted} –≤ {data.get('booking_time')}\nüíá {data.get('service_name')} ‚Äî {data.get('price')}‚ÇΩ{master_text}\n\n–ñ–¥—ë–º –≤–∞—Å! üí´")
    
    from handlers.start import get_main_keyboard
    user_bookings = db_manager.get_user_bookings(callback.from_user.id, active_only=True)
    if user_bookings:
        profile_text = "üìã <b>–í–ê–®–ò –ó–ê–ü–ò–°–ò</b>\n" + "‚îÅ"*20 + "\n\n"
        buttons = []
        for booking in user_bookings:
            # ... (formatting logic for each booking) ...
            buttons.append([InlineKeyboardButton(text=f"‚úèÔ∏è –ò–∑–º–µ–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å #{booking['id']}", callback_data=f"edit_booking:{booking['id']}")])
            buttons.append([InlineKeyboardButton(text=f"üóë –û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–ø–∏—Å—å #{booking['id']}", callback_data=f"cancel_order:{booking['id']}")])
        await callback.message.answer(profile_text, reply_markup=InlineKeyboardMarkup(inline_keyboard=buttons))
    await callback.message.answer("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", reply_markup=get_main_keyboard())

async def send_admin_notification(callback: CallbackQuery, config: dict, data: dict, order_id: int, db_manager):
    try:
        await send_order_to_admins(
            bot=callback.message.bot,
            admin_ids=config.get('admin_ids', []),
            order_data={
                'order_id': order_id,
                'user_id': callback.from_user.id,
                'service_name': data.get('service_name'),
                'price': data.get('price'),
                'booking_date': data.get('booking_date'),
                'booking_time': data.get('booking_time'),
                'client_name': data.get('client_name'),
                'phone': data.get('phone'),
                'username': callback.from_user.username,
                'master_name': data.get('master_name')
            },
            business_name=config.get('business_name', ''),
            db_manager=db_manager
        )
    except Exception as e:
        logger.error(f"Failed to notify admins: {e}")

async def return_to_time_selection(callback: CallbackQuery, state: FSMContext, config: dict, db_manager):
    data = await state.get_data()
    keyboard = get_time_slots_keyboard(config, db_manager, data.get('booking_date'), master_id=data.get('master_id'))
    await callback.message.edit_text(f"üìÖ {data.get('booking_date')}\n\n‚ö†Ô∏è –í—ã–±—Ä–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è –∑–∞–Ω—è—Ç–æ. –í—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥–æ–µ:", reply_markup=keyboard)
    await state.set_state(BookingState.choosing_time)

=== FILE: handlers/booking/service.py ===
"""
–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ —É—Å–ª—É–≥–∏.
"""
import logging
from aiogram import Router
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext
from states.booking import BookingState
from .keyboards import get_services_keyboard
from .master import show_masters_for_service

logger = logging.getLogger(__name__)

router = Router()

async def show_services_list(callback_or_message: Message | CallbackQuery, state: FSMContext, config: dict, category_name: str = None):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —É—Å–ª—É–≥, –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ —Ñ–∏–ª—å—Ç—Ä—É—è –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏."""
    services = config.get('services', [])
    message = callback_or_message if isinstance(callback_or_message, Message) else callback_or_message.message

    if category_name:
        # –§–∏–ª—å—Ç—Ä—É–µ–º —É—Å–ª—É–≥–∏ –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
        services_in_category = [s for s in services if s.get('category') == category_name]
    else:
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ —É—Å–ª—É–≥–∏, –µ—Å–ª–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è
        services_in_category = services

    if not services_in_category:
        await message.answer("–í —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —É—Å–ª—É–≥. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥—É—é.")
        return

    await message.answer(
        text=config.get('messages', {}).get('service_selection', "–í—ã–±–µ—Ä–∏—Ç–µ —É—Å–ª—É–≥—É:"),
        reply_markup=get_services_keyboard(services_in_category, category_name)
    )
    await state.set_state(BookingState.choosing_master)

=== FILE: handlers/booking/time.py ===
"""
–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏.
"""

import logging
from datetime import datetime, time, date
from aiogram import Router, F
from aiogram.types import CallbackQuery, Message
from aiogram.fsm.context import FSMContext

from states.booking import BookingState
from ..keyboards import get_time_slots_keyboard
from .contact import request_contact_info

logger = logging.getLogger(__name__)

router = Router()

async def show_time_slots(callback_or_message, state: FSMContext, config: dict, db_manager, selected_date: date):
    """Displays available time slots for the selected date."""
    data = await state.get_data()
    master_id = data.get('master_id')
    
    # Decide if we're editing a message or sending a new one
    message = callback_or_message if isinstance(callback_or_message, Message) else callback_or_message.message

    # Fetch busy slots from the database
    busy_slots = db_manager.get_busy_slots(selected_date.isoformat(), master_id)

    # Generate all possible time slots based on config
    work_hours_str = config.get('work_hours', {}).get(selected_date.strftime('%A').lower(), "09:00-18:00")
    start_work_str, end_work_str = work_hours_str.split('-')
    start_work_time = datetime.strptime(start_work_str, '%H:%M').time()
    end_work_time = datetime.strptime(end_work_str, '%H:%M').time()
    interval_minutes = config.get('booking_settings', {}).get('time_slot_interval', 30)

    all_slots = []
    current_time = datetime.combine(selected_date, start_work_time)
    end_datetime = datetime.combine(selected_date, end_work_time)

    while current_time < end_datetime:
        all_slots.append(current_time.strftime('%H:%M'))
        current_time += timedelta(minutes=interval_minutes)

    # Filter out busy slots
    available_slots = [slot for slot in all_slots if slot not in busy_slots]
    
    if not available_slots:
        await message.edit_text("–ù–∞ –≤—ã–±—Ä–∞–Ω–Ω—É—é –¥–∞—Ç—É –Ω–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –¥—Ä—É–≥—É—é –¥–∞—Ç—É.")
        # Here you might want to send the calendar back
        # from .date import proceed_to_date_selection
        # await proceed_to_date_selection(callback_or_message, state, config, ...)
        return

    keyboard = get_time_slots_keyboard(available_slots)
    await message.edit_text(f"üïí –í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è –Ω–∞ {selected_date.strftime('%d.%m.%Y')}:", reply_markup=keyboard)
    await state.set_state(BookingState.choosing_time)

@router.callback_query(BookingState.choosing_time, F.data.startswith("time:"))
async def time_selected(callback: CallbackQuery, state: FSMContext, db_manager):
    """Handles the selection of a time slot."""
    selected_time_str = callback.data.split(":", 1)[1]
    data = await state.get_data()
    booking_date = date.fromisoformat(data.get('booking_date'))
    
    # Combine date and time to create a full datetime object
    booking_datetime = datetime.combine(booking_date, time.fromisoformat(selected_time_str))
    
    await state.update_data(booking_datetime=booking_datetime.isoformat())
    logger.info(f"User {callback.from_user.id} selected time: {booking_datetime.isoformat()}")
    
    # Proceed to contact info request
    await request_contact_info(callback, state, db_manager)
    await callback.answer()
=== FILE: handlers/booking/utils.py ===
"""
–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –ø—Ä–æ—Ü–µ—Å—Å–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è.
"""

def get_categories_from_services(services: list) -> list:
    """Extracts unique categories from a list of services."""
    categories = []
    for service in services:
        if service.get('category') and service['category'] not in categories:
            categories.append(service['category'])
    return categories

def get_services_by_category(services: list, category_name: str) -> list:
    """Filters services by a given category name."""
    return [s for s in services if s.get('category') == category_name]

def get_masters_for_service(config: dict, service_id: str) -> list:
    """Gets a list of masters who provide a specific service."""
    staff_list = config.get('staff', {}).get('list', [])
    return [master for master in staff_list if service_id in master.get('services', [])]

def get_master_by_id(config: dict, master_id: str) -> dict or None:
    """Finds a master by their ID."""
    return next((m for m in config.get('staff', {}).get('list', []) if m['id'] == master_id), None)

=== FILE: main.py ===

import argparse
import asyncio
import logging
import os
from dotenv import load_dotenv
from aiogram import Bot, Dispatcher, BaseMiddleware
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import TelegramObject, Message
from typing import Any, Awaitable, Callable, Dict

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∏–∑ .env
load_dotenv()

# –ò–º–ø–æ—Ä—Ç—ã –∏–∑ –ø—Ä–æ–µ–∫—Ç–∞
from utils.db import DatabaseManager
from utils.logger import setup_logger
from utils.config_loader import load_config

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º handlers
from handlers import all_routers


async def watch_config_updates(config_path: str, config: dict, poll_interval_seconds: float = 3.0):
    """
    –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ —Å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–º–∏ —Ñ–∞–π–ª–∞–º–∏.
    –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–û: —Ñ–∞–π–ª—ã —á–∏—Ç–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏–∑–º–µ–Ω–∏–ª—Å—è mtime –∏–ª–∏ –≤–µ—Ä—Å–∏—è.
    """
    last_mtime = None
    last_version = config.get('config_version', 0)

    def get_latest_mtime(path: str):
        try:
            files = [os.path.join(path, f) for f in os.listdir(path) if f.endswith('.json')]
            if not files:
                return None
            return max(os.path.getmtime(f) for f in files)
        except Exception:
            return None

    last_mtime = get_latest_mtime(config_path)

    while True:
        await asyncio.sleep(poll_interval_seconds)

        current_mtime = get_latest_mtime(config_path)
        if current_mtime is None:
            continue

        if last_mtime is not None and current_mtime == last_mtime:
            continue

        try:
            new_config = load_config(config_path)
        except Exception as e:
            logging.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é: {e}")
            last_mtime = current_mtime
            continue

        new_version = new_config.get('config_version', 0)

        if new_version == last_version:
            last_mtime = current_mtime
            continue

        config.clear()
        config.update(new_config)

        last_mtime = current_mtime
        last_version = new_version
        logging.info(f"üîÑ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞ (config_version={last_version})")


class ConfigMiddleware(BaseMiddleware):
    """Middleware –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ config, db_manager –∏ admin_bot –≤ handlers"""
    def __init__(self, config: dict, db_manager, admin_bot: Bot = None):
        super().__init__()
        self.config = config
        self.db_manager = db_manager
        self.admin_bot = admin_bot

    async def __call__(
        self,
        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
        event: TelegramObject,
        data: Dict[str, Any]
    ) -> Any:
        data['config'] = self.config
        data['messages'] = self.config.get('messages', {})
        data['db_manager'] = self.db_manager
        data['admin_bot'] = self.admin_bot
        return await handler(event, data)


async def main():
    setup_logger()
    logger = logging.getLogger(__name__)

    parser = argparse.ArgumentParser(description='Telegram Business Bot V2.0')
    parser.add_argument('--config-dir', type=str, default='config',
                        help='–ü—É—Ç—å –∫ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ —Å JSON —Ñ–∞–π–ª–∞–º–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏.')
    args = parser.parse_args()

    try:
        config = load_config(args.config_dir)
        logger.info(f"‚úÖ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω–∞: {config.get('business_name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}")
    except Exception as e:
        logger.critical(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏–∑ '{args.config_dir}': {e}", exc_info=True)
        return

    bot_token = os.getenv('BOT_TOKEN') or config.get('bot_token')
    
    if not bot_token:
        logger.critical("‚ùå BOT_TOKEN –Ω–µ –Ω–∞–π–¥–µ–Ω –Ω–∏ –≤ .env, –Ω–∏ –≤ –∫–æ–Ω—Ñ–∏–≥–µ!")
        return

    business_slug = config.get('business_slug', 'default_business')
    db_manager = DatabaseManager(business_slug)
    
    try:
        logger.info(f"‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞: db_{business_slug}.sqlite")
    except Exception as e:
        logger.critical(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ë–î: {e}", exc_info=True)
        return

    bot = Bot(
        token=bot_token,
        default=DefaultBotProperties(parse_mode=ParseMode.HTML)
    )

    admin_bot = None
    admin_token = os.getenv('ADMIN_BOT_TOKEN')
    if admin_token:
        admin_bot = Bot(
            token=admin_token,
            default=DefaultBotProperties(parse_mode=ParseMode.HTML)
        )
        logger.info("‚úÖ –ê–¥–º–∏–Ω-–±–æ—Ç –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    else:
        logger.warning("‚ö†Ô∏è ADMIN_BOT_TOKEN –Ω–µ –Ω–∞–π–¥–µ–Ω - —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –±—É–¥—É—Ç —á–µ—Ä–µ–∑ –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–≥–æ –±–æ—Ç–∞")

    storage = MemoryStorage()
    dp = Dispatcher(storage=storage)

    dp.update.middleware(ConfigMiddleware(config, db_manager, admin_bot))

    watcher_task = asyncio.create_task(watch_config_updates(args.config_dir, config))

    dp.include_router(all_routers)
    
    from aiogram.filters import StateFilter
    from aiogram import F

    known_menu_texts = {
        "üè† –ú–µ–Ω—é", "‚óÄÔ∏è –ù–∞–∑–∞–¥", "üìÖ –ó–∞–ø–∏—Å–∞—Ç—å—Å—è", "üìã –ú–æ–∏ –∑–∞–ø–∏—Å–∏",
        "üíÖ –£—Å–ª—É–≥–∏ –∏ —Ü–µ–Ω—ã", "üë©‚Äçüé® –ú–∞—Å—Ç–µ—Ä–∞", "üéÅ –ê–∫—Ü–∏–∏", "‚ÑπÔ∏è –û –Ω–∞—Å", "‚ùì FAQ",
        "üìç –ê–¥—Ä–µ—Å", "üìÖ –ó–∞–ø–∏—Å–∞—Ç—å—Å—è / –ó–∞–∫–∞–∑–∞—Ç—å", "‚ùì –ß–∞—Å—Ç–æ –∑–∞–¥–∞–≤–∞–µ–º—ã–µ –≤–æ–ø—Ä–æ—Å—ã",
        "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
    }

    @dp.message(StateFilter(None), F.text, ~F.text.startswith("/"), ~F.text.in_(known_menu_texts))
    async def unknown_message_handler(message: Message):
        from handlers.start import get_main_keyboard
        await message.answer(
            "–Ø –Ω–µ –ø–æ–Ω—è–ª –≤–∞—à –∑–∞–ø—Ä–æ—Å. –í–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–Ω–æ–ø–∫–∞–º–∏ –º–µ–Ω—é –Ω–∏–∂–µ:",
            reply_markup=get_main_keyboard()
        )

    logger.info(f"üöÄ –ë–æ—Ç '{config.get('business_name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}' –∑–∞–ø—É—â–µ–Ω!")
    logger.info(f"üìÇ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–∑ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: {args.config_dir}")
    logger.info(f"üíæ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö: db_{business_slug}.sqlite")
    logger.info("üíæ –•—Ä–∞–Ω–∏–ª–∏—â–µ FSM: MemoryStorage")

    try:
        await bot.delete_webhook(drop_pending_updates=True)
        await dp.start_polling(bot)
    except KeyboardInterrupt:
        logger.info("–ü–æ–ª—É—á–µ–Ω–æ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–µ —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤–æ –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã: {e}", exc_info=True)
    finally:
        watcher_task.cancel()
        try:
            await watcher_task
        except asyncio.CancelledError:
            pass
        db_manager.close()
        await bot.session.close()
        if admin_bot:
            await admin_bot.session.close()
        logger.info("üõë –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")


if __name__ == '__main__':
    asyncio.run(main())

=== FILE: utils/db/__init__.py ===
import random

class DatabaseManager:
    def __init__(self, business_slug):
        self.business_slug = business_slug
        # –ó–¥–µ—Å—å –±—É–¥–µ—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        pass

    def get_order_by_id(self, order_id):
        # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∑–∞–∫–∞–∑–∞
        return None

    def check_slot_availability(self, date, time, exclude_order_id=None):
        # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Å–ª–æ—Ç–∞ (–æ–±—â–∞—è)
        return True

    def check_slot_availability_for_master(self, date, time, master_id, exclude_order_id=None):
        # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Å–ª–æ—Ç–∞ —É –º–∞—Å—Ç–µ—Ä–∞
        return True

    def check_slot_availability_excluding(self, date, time, order_id):
        # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Å–ª–æ—Ç–∞ –ø—Ä–∏ –ø–µ—Ä–µ–Ω–æ—Å–µ
        return True

    def get_user_bookings(self, user_id, active_only=True):
        # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∑–∞–ø–∏—Å–µ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        return []

    def get_last_client_details(self, user_id):
        # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –¥–∞–Ω–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–∞
        return None

    def add_order(self, user_id, service_id, service_name, price, client_name, phone, comment, booking_date, booking_time, master_id):
        # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∑–∞–∫–∞–∑–∞
        return random.randint(1000, 9999)

    def add_user(self, user_id, username, first_name, last_name):
        # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        pass

    def get_master_and_service_ids(self, master_id_str, service_id_str):
        # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è ID –º–∞—Å—Ç–µ—Ä–∞ –∏ —É—Å–ª—É–≥–∏
        try:
            return int(master_id_str), int(service_id_str)
        except (ValueError, TypeError):
            return 1, 1 # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ–∏–∫—Ç–∏–≤–Ω—ã–µ ID –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏

=== FILE: utils/db/booking_queries.py ===

import sqlite3
import logging
from datetime import datetime
from utils.privacy import safe_log_order_creation

logger = logging.getLogger(__name__)

class BookingQueries:

    def __init__(self, db_connection):
        self.connection = db_connection

    def _ensure_connection(self):
        if not self.connection:
            raise RuntimeError("Database not initialized.")
        try:
            self.connection.execute("SELECT 1")
        except sqlite3.Error:
            raise RuntimeError("Database connection lost.")

    def add_order(self, user_id: int, service_id: str, service_name: str, price: int,
                  client_name: str, phone: str, comment: str = None,
                  booking_date: str = None, booking_time: str = None,
                  master_id: str = None) -> int:
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–∫–∞–∑–∞ —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç race condition"""
        try:
            self._ensure_connection()
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º `with self.connection` –¥–ª—è –∞—Ç–æ–º–∞—Ä–Ω–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
            with self.connection:
                cursor = self.connection.cursor()
                created_at = datetime.now().isoformat()

                # –®–∞–≥ 1: –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Å–ª–æ—Ç–∞
                if booking_date and booking_time:
                    if master_id:
                        cursor.execute("""
                            SELECT COUNT(*) FROM orders
                            WHERE booking_date = ? AND booking_time = ? AND master_id = ? AND status = 'active'
                        """, (booking_date, booking_time, master_id))
                    else:
                        cursor.execute("""
                            SELECT COUNT(*) FROM orders
                            WHERE booking_date = ? AND booking_time = ? AND status = 'active'
                        """, (booking_date, booking_time))
                    
                    if cursor.fetchone()[0] > 0:
                        raise ValueError(f"–°–ª–æ—Ç {booking_date} {booking_time} —É–∂–µ –∑–∞–Ω—è—Ç")

                # –®–∞–≥ 2: –°–æ–∑–¥–∞–µ–º –∑–∞–∫–∞–∑ (–µ—Å–ª–∏ —Å–ª–æ—Ç —Å–≤–æ–±–æ–¥–µ–Ω)
                cursor.execute("""
                    INSERT INTO orders (user_id, service_id, service_name, price, client_name, phone,
                                       comment, booking_date, booking_time, master_id, status, created_at)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'active', ?)
                """, (user_id, service_id, service_name, price, client_name, phone,
                      comment, booking_date, booking_time, master_id, created_at))

                order_id = cursor.lastrowid

            # –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä `with` –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è (commit)
            # –∏–ª–∏ –æ—Ç–∫–∞—Ç—ã–≤–∞–µ—Ç –∏—Ö (rollback) –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏.

            log_msg = safe_log_order_creation(
                user_id=user_id,
                service_name=service_name,
                client_name=client_name,
                phone=phone,
                booking_date=booking_date,
                booking_time=booking_time
            )
            master_info = f", master_id={master_id}" if master_id else ""
            logger.info(f"ID={order_id}, {log_msg}{master_info}")

            return order_id

        except ValueError as e:
            # –û—à–∏–±–∫–∞ (—Å–ª–æ—Ç –∑–∞–Ω—è—Ç) –±—É–¥–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞, —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Ç–º–µ–Ω–µ–Ω–∞
            logger.warning(f"Slot already taken: {e}")
            raise
        except sqlite3.Error as e:
            # –û—à–∏–±–∫–∞ –ë–î, —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Ç–º–µ–Ω–µ–Ω–∞
            logger.error(f"Error adding order: {e}")
            raise

    def get_user_bookings(self, user_id: int, active_only: bool = True) -> list:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –∑–∞–ø–∏—Å–µ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            self._ensure_connection()
            cursor = self.connection.cursor()

            if active_only:
                cursor.execute("""
                    SELECT id, service_name, booking_date, booking_time, price, status,
                           created_at, comment, client_name, phone, master_id
                    FROM orders
                    WHERE user_id = ? AND status = 'active'
                      AND (booking_date IS NULL OR booking_date >= date('now'))
                    ORDER BY COALESCE(booking_date, date('now')), booking_time
                """, (user_id,))
            else:
                cursor.execute("""
                    SELECT id, service_name, booking_date, booking_time, price, status,
                           created_at, comment, client_name, phone, master_id
                    FROM orders
                    WHERE user_id = ?
                    ORDER BY created_at DESC
                """, (user_id,))

            rows = cursor.fetchall()
            bookings = []

            for row in rows:
                bookings.append({
                    'id': row[0],
                    'service_name': row[1],
                    'booking_date': row[2],
                    'booking_time': row[3],
                    'price': row[4],
                    'status': row[5],
                    'created_at': row[6],
                    'comment': row[7] if len(row) > 7 else None,
                    'client_name': row[8] if len(row) > 8 else None,
                    'phone': row[9] if len(row) > 9 else None,
                    'master_id': row[10] if len(row) > 10 else None
                })

            return bookings

        except sqlite3.Error as e:
            logger.error(f"Error getting user bookings: {e}")
            return []

    def get_order_by_id(self, order_id: int) -> dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∑–∞–∫–∞–∑–µ –ø–æ ID"""
        try:
            self._ensure_connection()
            cursor = self.connection.cursor()
            cursor.execute("""
                SELECT id, user_id, service_id, service_name, price, booking_date, booking_time,
                       client_name, phone, comment, status, master_id
                FROM orders
                WHERE id = ?
            """, (order_id,))

            row = cursor.fetchone()

            if row:
                return {
                    'id': row[0],
                    'user_id': row[1],
                    'service_id': row[2],
                    'service_name': row[3],
                    'price': row[4],
                    'booking_date': row[5],
                    'booking_time': row[6],
                    'client_name': row[7],
                    'phone': row[8],
                    'comment': row[9],
                    'status': row[10],
                    'master_id': row[11] if len(row) > 11 else None
                }

            return None

        except sqlite3.Error as e:
            logger.error(f"Error getting order by ID: {e}")
            return None

    def update_order(self, order_id: int, **kwargs) -> bool:
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª–µ–π –∑–∞–∫–∞–∑–∞"""
        try:
            self._ensure_connection()
            set_parts = []
            values = []
            allowed_fields = ['service_id', 'service_name', 'price', 'booking_date',
                            'booking_time', 'client_name', 'phone', 'comment', 'master_id']

            for field, value in kwargs.items():
                if field in allowed_fields:
                    set_parts.append(f"{field} = ?")
                    values.append(value)

            if not set_parts:
                logger.warning("No valid fields to update")
                return False

            values.append(order_id)
            cursor = self.connection.cursor()
            query = f"UPDATE orders SET {', '.join(set_parts)} WHERE id = ?"
            cursor.execute(query, values)
            self.connection.commit()

            logger.info(f"Order {order_id} updated: {kwargs}")
            return cursor.rowcount > 0

        except sqlite3.Error as e:
            logger.error(f"Error updating order: {e}")
            return False

    def cancel_order(self, order_id: int) -> bool:
        """–û—Ç–º–µ–Ω–∞ –∑–∞–∫–∞–∑–∞"""
        try:
            self._ensure_connection()
            cursor = self.connection.cursor()
            cursor.execute("""
                UPDATE orders SET status = 'cancelled' WHERE id = ?
            """, (order_id,))

            self.connection.commit()
            logger.info(f"Order {order_id} cancelled")
            return cursor.rowcount > 0

        except sqlite3.Error as e:
            logger.error(f"Error cancelling order: {e}")
            return False

    def get_active_orders_for_reminders(self) -> list:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤ –¥–ª—è —Å–∏—Å—Ç–µ–º—ã –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π"""
        try:
            self._ensure_connection()
            cursor = self.connection.cursor()
            cursor.execute("""
                SELECT id, user_id, service_name, booking_date, booking_time
                FROM orders
                WHERE status = 'active' AND booking_date >= date('now')
                ORDER BY booking_date, booking_time
            """)

            rows = cursor.fetchall()
            orders = []

            for row in rows:
                orders.append({
                    'id': row[0],
                    'user_id': row[1],
                    'service_name': row[2],
                    'booking_date': row[3],
                    'booking_time': row[4]
                })

            return orders

        except sqlite3.Error as e:
            logger.error(f"Error getting orders for reminders: {e}")
            return []

=== FILE: utils/db/database.py ===

import sqlite3
import logging

logger = logging.getLogger(__name__)

LATEST_SCHEMA_VERSION = 3

# –ë–µ–ª—ã–π —Å–ø–∏—Å–æ–∫ —Ç–∞–±–ª–∏—Ü –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç SQL injection
ALLOWED_TABLES = {'orders', 'users', 'schema_migrations'}

class Database:
    def __init__(self, business_slug: str):
        self.db_path = f"db_{business_slug}.sqlite"
        self.connection = None

    def _ensure_connection(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å –ë–î"""
        if not self.connection:
            raise RuntimeError("Database not initialized. Call init_db() first.")
        try:
            self.connection.execute("SELECT 1")
        except sqlite3.Error:
            logger.warning("DB connection lost, reconnecting...")
            try:
                self.connection.close()
            except Exception:
                pass
            self.connection = sqlite3.connect(self.db_path, check_same_thread=False)
            try:
                self.connection.execute("PRAGMA foreign_keys = ON")
                self.connection.execute("PRAGMA busy_timeout = 5000")
                self.connection.execute("PRAGMA journal_mode = WAL")
                self.connection.execute("PRAGMA synchronous = NORMAL")
            except Exception:
                pass

    def _table_exists(self, cursor, table_name: str) -> bool:
        cursor.execute(
            "SELECT 1 FROM sqlite_master WHERE type='table' AND name=? LIMIT 1",
            (table_name,),
        )
        return cursor.fetchone() is not None

    def _column_exists(self, cursor, table_name: str, column_name: str) -> bool:
        if table_name not in ALLOWED_TABLES:
            logger.error(f"Invalid table name: {table_name}")
            return False
        try:
            cursor.execute(f"PRAGMA table_info({table_name})")
            cols = cursor.fetchall()
            return any(row[1] == column_name for row in cols)
        except sqlite3.Error:
            return False

    def _get_schema_version(self, cursor) -> int:
        if not self._table_exists(cursor, 'schema_migrations'):
            cursor.execute(
                "CREATE TABLE IF NOT EXISTS schema_migrations (version INTEGER NOT NULL)"
            )
            cursor.execute("DELETE FROM schema_migrations")
            cursor.execute("INSERT INTO schema_migrations(version) VALUES (0)")
            return 0

        cursor.execute("SELECT version FROM schema_migrations LIMIT 1")
        row = cursor.fetchone()
        if not row:
            cursor.execute("INSERT INTO schema_migrations(version) VALUES (0)")
            return 0
        try:
            return int(row[0] or 0)
        except Exception:
            return 0

    def _set_schema_version(self, cursor, version: int) -> None:
        cursor.execute("DELETE FROM schema_migrations")
        cursor.execute("INSERT INTO schema_migrations(version) VALUES (?)", (int(version),))

    def _apply_migrations(self, cursor) -> None:
        current_version = self._get_schema_version(cursor)
        target_version = LATEST_SCHEMA_VERSION

        if current_version >= target_version:
            return

        logger.info(f"Applying DB migrations: {current_version} -> {target_version}")

        if current_version < 1:
            cursor.execute(
                """
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER UNIQUE NOT NULL,
                    username TEXT,
                    first_name TEXT,
                    last_name TEXT,
                    created_at TEXT NOT NULL
                )
                """
            )

            cursor.execute(
                """
                CREATE TABLE IF NOT EXISTS orders (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    service_id TEXT NOT NULL,
                    service_name TEXT NOT NULL,
                    price INTEGER NOT NULL,
                    client_name TEXT NOT NULL,
                    phone TEXT NOT NULL,
                    comment TEXT,
                    booking_date TEXT,
                    booking_time TEXT,
                    status TEXT DEFAULT 'active',
                    created_at TEXT NOT NULL
                )
                """
            )

            if self._table_exists(cursor, 'orders') and not self._column_exists(cursor, 'orders', 'comment'):
                cursor.execute("ALTER TABLE orders ADD COLUMN comment TEXT")

            cursor.execute(
                """
                CREATE INDEX IF NOT EXISTS idx_booking_slot
                ON orders(booking_date, booking_time, status)
                """
            )

            self._set_schema_version(cursor, 1)

        current_version = self._get_schema_version(cursor)
        if current_version < 2:
            cursor.execute(
                """
                CREATE INDEX IF NOT EXISTS idx_orders_user_created
                ON orders(user_id, created_at)
                """
            )

            cursor.execute(
                """
                CREATE INDEX IF NOT EXISTS idx_orders_status_booking_date
                ON orders(status, booking_date)
                """
            )

            cursor.execute(
                """
                CREATE INDEX IF NOT EXISTS idx_users_user_id
                ON users(user_id)
                """
            )

            self._set_schema_version(cursor, 2)

        current_version = self._get_schema_version(cursor)
        if current_version < 3:
            # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ–ª–æ–Ω–∫–∏ master_id –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –ø–µ—Ä—Å–æ–Ω–∞–ª–∞
            if not self._column_exists(cursor, 'orders', 'master_id'):
                cursor.execute("ALTER TABLE orders ADD COLUMN master_id TEXT")
                logger.info("Added master_id column to orders table")

            # –ò–Ω–¥–µ–∫—Å –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ –º–∞—Å—Ç–µ—Ä—É
            cursor.execute(
                """
                CREATE INDEX IF NOT EXISTS idx_orders_master_id
                ON orders(master_id, booking_date, booking_time)
                """
            )

            self._set_schema_version(cursor, 3)

        current_version = self._get_schema_version(cursor)
        if current_version < target_version:
            raise RuntimeError(
                f"Database schema migration did not reach target version: {current_version} != {target_version}"
            )

    def init_db(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –∏ —Å–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü"""
        try:
            self.connection = sqlite3.connect(self.db_path, check_same_thread=False)
            try:
                self.connection.execute("PRAGMA foreign_keys = ON")
            except Exception:
                pass
            try:
                self.connection.execute("PRAGMA busy_timeout = 5000")
            except Exception:
                pass
            try:
                self.connection.execute("PRAGMA journal_mode = WAL")
            except Exception:
                pass
            try:
                self.connection.execute("PRAGMA synchronous = NORMAL")
            except Exception:
                pass
            cursor = self.connection.cursor()

            self._apply_migrations(cursor)

            self.connection.commit()
            logger.info(f"Database initialized: {self.db_path}")

            try:
                cursor2 = self.connection.cursor()
                version_after = self._get_schema_version(cursor2)
                logger.info(f"Database schema version: {version_after}")
            except Exception:
                pass

        except Exception as e:
            logger.error(f"Database initialization/migration error: {e}")
            logger.error(
                "Database is not usable. Recommended actions:\n"
                "1) Check DB schema/version: sudo bash deploy/linux/db_info.sh\n"
                "2) Restore from backup:     sudo bash deploy/linux/restore.sh\n"
                "3) If issue persists: check disk space/permissions for db_*.sqlite"
            )
            try:
                if self.connection:
                    self.connection.rollback()
            except Exception:
                pass
            try:
                if self.connection:
                    self.connection.close()
            except Exception:
                pass
            self.connection = None
            raise

    def close(self):
        """–ó–∞–∫—Ä—ã—Ç–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å –ë–î"""
        if self.connection:
            self.connection.close()
            logger.info(f"Database connection closed: {self.db_path}")


=== FILE: utils/db/staff_queries.py ===

import sqlite3
import logging

from utils.db.booking_queries import BookingQueries

logger = logging.getLogger(__name__)

class StaffQueries(BookingQueries):

    def __init__(self, db_connection):
        super().__init__(db_connection)
        self.connection = db_connection

    def _ensure_connection(self):
        if not self.connection:
            raise RuntimeError("Database not initialized.")
        try:
            self.connection.execute("SELECT 1")
        except sqlite3.Error:
            raise RuntimeError("Database connection lost.")

    def check_slot_availability(self, booking_date: str, booking_time: str, exclude_order_id: int = None) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Å–ª–æ—Ç–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –º–∞—Å—Ç–µ—Ä–∞)"""
        try:
            self._ensure_connection()
            cursor = self.connection.cursor()

            query = """
                SELECT COUNT(*) FROM orders
                WHERE booking_date = ? AND booking_time = ? AND status = 'active'
            """
            params = [booking_date, booking_time]

            if exclude_order_id:
                query += " AND id != ?"
                params.append(exclude_order_id)

            cursor.execute(query, params)
            count = cursor.fetchone()[0]
            return count == 0

        except sqlite3.Error as e:
            logger.error(f"Error checking slot availability: {e}")
            return False

    def get_occupied_slots_for_master(self, booking_date: str, master_id: str) -> list:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∑–∞–Ω—è—Ç—ã—Ö —Å–ª–æ—Ç–æ–≤ –º–∞—Å—Ç–µ—Ä–∞ –Ω–∞ –¥–∞—Ç—É"""
        try:
            self._ensure_connection()
            cursor = self.connection.cursor()
            cursor.execute("""
                SELECT booking_time FROM orders
                WHERE booking_date = ? AND master_id = ? AND status = 'active'
            """, (booking_date, master_id))

            return [row[0] for row in cursor.fetchall()]

        except sqlite3.Error as e:
            logger.error(f"Error getting occupied slots for master: {e}")
            return []

    def check_slot_availability_for_master(self, booking_date: str, booking_time: str, master_id: str, exclude_order_id: int = None) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Å–ª–æ—Ç–∞ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –º–∞—Å—Ç–µ—Ä–∞ (–∞–ª–∏–∞—Å)"""
        try:
            self._ensure_connection()
            cursor = self.connection.cursor()
            query = """
                SELECT COUNT(*) FROM orders
                WHERE booking_date = ? AND booking_time = ? AND master_id = ? AND status = 'active'
            """
            params = [booking_date, booking_time, master_id]

            if exclude_order_id:
                query += " AND id != ?"
                params.append(exclude_order_id)

            cursor.execute(query, params)
            count = cursor.fetchone()[0]
            return count == 0
        except sqlite3.Error as e:
            logger.error(f"Error checking slot availability for master: {e}")
            return False

    def check_slot_availability_excluding(
        self,
        booking_date: str,
        booking_time: str,
        exclude_order_id: int
    ) -> bool:
        """
        –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å–≤–æ–±–æ–¥–µ–Ω –ª–∏ —Å–ª–æ—Ç (–¥–∞—Ç–∞ + –≤—Ä–µ–º—è) –¥–ª—è –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è,
        –∏—Å–∫–ª—é—á–∞—è –∏–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∑–∞–∫–∞–∑ exclude_order_id (–ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏).
        """
        try:
            self._ensure_connection()

            # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º–æ–º –∑–∞–∫–∞–∑–µ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –º–∞—Å—Ç–µ—Ä–∞
            order = self.get_order_by_id(exclude_order_id)
            master_id = order.get('master_id') if order else None

            cursor = self.connection.cursor()

            if master_id:
                cursor.execute("""
                    SELECT COUNT(*) FROM orders
                    WHERE booking_date = ?
                      AND booking_time = ?
                      AND master_id = ?
                      AND status = 'active'
                      AND id != ?
                """, (booking_date, booking_time, master_id, exclude_order_id))
            else:
                cursor.execute("""
                    SELECT COUNT(*) FROM orders
                    WHERE booking_date = ?
                      AND booking_time = ?
                      AND status = 'active'
                      AND id != ?
                """, (booking_date, booking_time, exclude_order_id))

            count = cursor.fetchone()[0]
            return count == 0

        except sqlite3.Error as e:
            logger.error(f"Error checking slot availability excluding order {exclude_order_id}: {e}")
            return False

=== FILE: utils/db/stats_queries.py ===

import sqlite3
import logging
from datetime import datetime, timedelta
from io import StringIO
import csv

logger = logging.getLogger(__name__)

class StatsQueries:

    def __init__(self, db_connection):
        self.connection = db_connection

    def _ensure_connection(self):
        if not self.connection:
            raise RuntimeError("Database not initialized.")
        try:
            self.connection.execute("SELECT 1")
        except sqlite3.Error:
            raise RuntimeError("Database connection lost.")

    def get_stats(self, period: str = 'today') -> dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç SQL injection"""
        try:
            self._ensure_connection()
            cursor = self.connection.cursor()

            ALLOWED_PERIODS = {'today', 'week', 'month'}
            if period not in ALLOWED_PERIODS:
                logger.warning(f"Invalid period: {period}, using 'today'")
                period = 'today'

            if period == 'today':
                days_back = 0
            elif period == 'week':
                days_back = 7
            else:  # month
                days_back = 30

            cutoff_date = (datetime.now() - timedelta(days=days_back)).date().isoformat()

            cursor.execute("""
                SELECT COUNT(*) FROM orders
                WHERE created_at >= ? AND status = 'active'
            """, (cutoff_date,))
            total_orders = cursor.fetchone()[0]

            cursor.execute("""
                SELECT COUNT(*) FROM orders
                WHERE created_at >= ? AND status = 'active'
                AND booking_date > date('now')
            """, (cutoff_date,))
            planned_orders = cursor.fetchone()[0]

            cursor.execute("""
                SELECT service_name, COUNT(*) as count
                FROM orders
                WHERE created_at >= ? AND status = 'active'
                GROUP BY service_name
                ORDER BY count DESC
                LIMIT 5
            """, (cutoff_date,))
            top_services = cursor.fetchall()

            cursor.execute("""
                SELECT SUM(price) FROM orders
                WHERE created_at >= ? AND status = 'active'
                AND (booking_date IS NULL OR booking_date <= date('now'))
            """, (cutoff_date,))
            total_revenue = cursor.fetchone()[0] or 0

            cursor.execute("""
                SELECT SUM(price) FROM orders
                WHERE created_at >= ? AND status = 'active'
                AND booking_date > date('now')
            """, (cutoff_date,))
            planned_revenue = cursor.fetchone()[0] or 0

            cursor.execute("""
                SELECT COUNT(*) FROM users
                WHERE created_at >= ?
            """, (cutoff_date,))
            new_clients = cursor.fetchone()[0]

            return {
                'total_orders': total_orders,
                'planned_orders': planned_orders,
                'top_services': [(name, count) for name, count in top_services],
                'total_revenue': total_revenue,
                'planned_revenue': planned_revenue,
                'new_clients': new_clients
            }

        except sqlite3.Error as e:
            logger.error(f"Error getting stats: {e}")
            return {
                'total_orders': 0,
                'planned_orders': 0,
                'top_services': [],
                'total_revenue': 0,
                'planned_revenue': 0,
                'new_clients': 0
            }

    def get_orders_csv(self, days: int = 30) -> bytes:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∑–∞–∫–∞–∑–æ–≤ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ N –¥–Ω–µ–π –≤ —Ñ–æ—Ä–º–∞—Ç–µ CSV"""
        try:
            self._ensure_connection()
            cursor = self.connection.cursor()
            cutoff_date = (datetime.now() - timedelta(days=days)).isoformat()

            cursor.execute("""
                SELECT id, user_id, service_id, service_name, price, client_name, phone,
                       comment, booking_date, booking_time, status, created_at
                FROM orders
                WHERE created_at >= ?
                ORDER BY created_at DESC
            """, (cutoff_date,))

            rows = cursor.fetchall()
            output = StringIO()
            writer = csv.writer(output, delimiter=';')

            writer.writerow(['ID', 'User ID', 'Service ID', 'Service Name', 'Price',
                           'Client Name', 'Phone', 'Comment', 'Booking Date',
                           'Booking Time', 'Status', 'Created At'])

            for row in rows:
                writer.writerow(row)

            csv_content = output.getvalue()
            output.close()

            return csv_content.encode('utf-8-sig')

        except sqlite3.Error as e:
            logger.error(f"Error generating CSV: {e}")
            raise

    def get_statistics_by_period(self, start_date: str, end_date: str) -> dict:
        """
        –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥
        """
        cursor = self.connection.execute("""
            SELECT 
                COUNT(*) as total_bookings,
                SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
                SUM(CASE WHEN status = 'cancelled' THEN 1 ELSE 0 END) as cancelled,
                SUM(CASE WHEN status = 'completed' THEN price ELSE 0 END) as revenue
            FROM orders
            WHERE booking_date >= ? AND booking_date <= ?
        """, (start_date, end_date))
        
        row = cursor.fetchone()
        
        return {
            'total_bookings': row[0] or 0,
            'completed': row[1] or 0,
            'cancelled': row[2] or 0,
            'revenue': row[3] or 0
        }

=== FILE: utils/db/user_queries.py ===

import sqlite3
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class UserQueries:

    def __init__(self, db_connection):
        self.connection = db_connection

    def _ensure_connection(self):
        if not self.connection:
            raise RuntimeError("Database not initialized.")
        try:
            self.connection.execute("SELECT 1")
        except sqlite3.Error:
            # The connection should be managed by the Database class
            raise RuntimeError("Database connection lost.")

    def add_user(self, user_id: int, username: str = None, first_name: str = None, last_name: str = None):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            self._ensure_connection()
            cursor = self.connection.cursor()
            created_at = datetime.now().isoformat()

            cursor.execute("""
                INSERT OR IGNORE INTO users (user_id, username, first_name, last_name, created_at)
                VALUES (?, ?, ?, ?, ?)
            """, (user_id, username, first_name, last_name, created_at))

            self.connection.commit()

        except sqlite3.Error as e:
            logger.error(f"Error adding user: {e}")

    def get_last_client_details(self, user_id: int) -> dict | None:
        try:
            self._ensure_connection()
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT client_name, phone
                FROM orders
                WHERE user_id = ?
                ORDER BY created_at DESC
                LIMIT 1
                """,
                (user_id,),
            )
            row = cursor.fetchone()
            if not row:
                return None
            return {'client_name': row[0], 'phone': row[1]}
        except sqlite3.Error as e:
            logger.error(f"Error getting last client details: {e}")
            return None
